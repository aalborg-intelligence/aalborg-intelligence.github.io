<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Simple kunstige neruale netværk til regression – AI MAT - matematikken bag magien</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo/SVG/Bomaerke_05_AIMAT_2024.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-cef6446724503988638a0362fd982987.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Y219BCPS45"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
 
  gtag('consent', 'default', {
    'ad_storage': 'denied',
    'analytics_storage': 'denied'
  });
gtag('config', 'G-Y219BCPS45', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo/PNG/Logo_multi_AIMAT_RGB_2024.png" alt="" class="navbar-logo light-content">
    <img src="../../logo/PNG/Logo_multi_AIMAT_RGB_2024.png" alt="" class="navbar-logo dark-content">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../undervisningsforlob/index.html"> 
<span class="menu-text">Undervisningsforløb</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../noter/index.html"> 
<span class="menu-text">Noter</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../srp/index.html"> 
<span class="menu-text">SRP</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../apps/index.html"> 
<span class="menu-text">Apps</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../til_laererne.html"> 
<span class="menu-text">Til lærerne</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> <i class="bi bi-envelope" role="img" aria-label="Om os">
</i> 
<span class="menu-text">Om os</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.youtube.com/@ai-mat" target="_blank"> <i class="bi bi-youtube" role="img" aria-label="YouTube">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Indhold</h2>
   
  <ul>
  <li><a href="#hvad-koster-mit-hus" id="toc-hvad-koster-mit-hus" class="nav-link active" data-scroll-target="#hvad-koster-mit-hus">Hvad koster mit hus?</a>
  <ul class="collapse">
  <li><a href="#fortolkning-af-vægtene" id="toc-fortolkning-af-vægtene" class="nav-link" data-scroll-target="#fortolkning-af-vægtene">Fortolkning af vægtene</a></li>
  </ul></li>
  <li><a href="#fortolkning-af-vægtene-1" id="toc-fortolkning-af-vægtene-1" class="nav-link" data-scroll-target="#fortolkning-af-vægtene-1">Fortolkning af vægtene</a></li>
  <li><a href="#prædiktion-af-huspriser-nu-med-skjulte-lag" id="toc-prædiktion-af-huspriser-nu-med-skjulte-lag" class="nav-link" data-scroll-target="#prædiktion-af-huspriser-nu-med-skjulte-lag">Prædiktion af huspriser – nu med skjulte lag!</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simple kunstige neruale netværk til regression</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Hvis du har læst nogle af vores andre noter om kunstige neurale netværk, så har de alle handlet om <strong>klassifikation</strong>. Det kunne for eksempel være: aktiverer en kunde et tilbud i en app? (ja/nej), bliver det regnvejr i morgen? (ja/nej), har en patient en bestemt sygdom? (ja/nej), hvilket af fire valg skal jeg træffe? De tre første eksempler er eksempler på det, som man kalder for <strong>binær klassifikation</strong> (fordi der kun er to muligheder), mens det sidste eksempel er et eksempel på <strong>multipel klassifikation</strong> (fordi der er mere end to muligheder). I denne note vil vi se på, hvordan man kan bruge kunstige neurale netværk til at forudsige en såkaldt numerisk variabel – mere konkret vil vi her se på, hvordan man kan lave et kunstigt neuralt netværk, som kan bruges til at prædiktere huspriser.</p>
<section id="hvad-koster-mit-hus" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="hvad-koster-mit-hus">Hvad koster mit hus?</h2>
<p>Vi forestiller os helt generelt en række inputvariable eller features: <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> på baggrund af hvilke vi gerne vil kunne forudsige en targetvariabel <span class="math inline">\(t\)</span>, som her er salgsprisen på et hus.</p>
<div id="exm-houseprices" class="theorem example">
<p><span class="theorem-title"><strong>Eksempel 1 (House Price datasættet)</strong></span> På <a href="https://www.kaggle.com/">kaggle.com</a> kan man downloade et utal af forskellige datasæt. Vi vil her se nærmere på datasættet <a href="https://www.kaggle.com/datasets/neurocipher/house-price-for-linear-regression">House Price Dataset for Regression Models</a>, som du kan downloade som <a href="data/Housing.xlsx">Excel fil her</a>.</p>
<p>Datasættet indeholder oplysninger om <span class="math inline">\(545\)</span> hussalg i USA.</p>
<p>Targetvariablen <span class="math inline">\(t\)</span> står i kolonnen <code>price</code> og angiver salgsprisen målt i dollar. Derudover indeholder datasættet en lang række features:</p>
<ul>
<li><p><code>area</code>: boligens areal målt i square feet</p></li>
<li><p><code>bedrooms</code>: antal værelser</p></li>
<li><p><code>bathrooms</code>: antal badeværelser</p></li>
<li><p><code>stories</code>: antal etager</p></li>
<li><p><code>mainroad</code>: om huset har adgang til hovedvejen (ja=1, nej=0)</p></li>
<li><p><code>guestroom</code>: om huset har et gæsteværelse (ja=1, nej=0)</p></li>
<li><p><code>basement</code>: om huset har kælder (ja=1, nej=0)</p></li>
<li><p><code>hotwaterheating</code>: om huset har fjernvarme (ja=1, nej=0)</p></li>
<li><p><code>airconditioning</code>: om huset air conditioning (ja=1, nej=0)</p></li>
<li><p><code>parking</code>: antal parkeringspladser</p></li>
<li><p><code>prefarea</code>: om huset ligger i et eftertragtet område (ja=1, nej=0)</p></li>
<li><p><code>furnishingstatus</code>: om huset et umøbleret, delvist møbleret eller fuldt møbleret</p></li>
</ul>
</div>
<p>Lad os starte simpelt og opstille en kunstig neuron til formålet. Så vil vi sige, at vores prædiktion af husprisen skal være en outputværdi <span class="math inline">\(o\)</span>, som er den vægtede sum af vores inputvariable:</p>
<p><span class="math display">\[
o = w_0 + w_1 \cdot x_1 + w_2 \cdot x_2 + \cdots + w_n \cdot x_n
\]</span></p>
<p>Her kaldes <span class="math inline">\(w_0, w_1, w_2, \dots, w_n\)</span> for vægte.</p>
<p>Hvis du har læst noten om <a href="../../noter/kunstige_neuroner/kunstige_neuroner.html">kunstige neuroner</a>, så er den eneste forskel her, at vi ikke længere bruger sigmoid-funktionen som aktiveringsfunktion<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, fordi vi ikke her har brug for at få en outputværdi, som ligger mellem <span class="math inline">\(0\)</span> og <span class="math inline">\(1\)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Vi bruger sådan set stadig en aktiveringsfunktion – det bare den funktion, som kaldes for <em>identiteten</em> med forskrift <span class="math inline">\(f(x)=x\)</span>.</p></div></div><p>Vi ønsker nu, at bestemme vægtene <span class="math inline">\(w_0, w_1, w_2, \dots, w_n\)</span> sådan at vores prædikterede huspris <span class="math inline">\(o\)</span> kommer så tæt som muligt på den faktiske huspris <span class="math inline">\(t\)</span>.</p>
<p>Det vil sige, at vi ønsker, at forskellen</p>
<p><span class="math display">\[
t-o = t - \left ( w_0 + w_1 \cdot x_1 + w_2 \cdot x_2 + \cdots + w_n \cdot x_n \right )
\]</span></p>
<p>bliver så lille som mulig.</p>
<p>Da denne differens både kan være positiv og negativ, men vi egentlig ikke er interesseret i fortegnet – blot om differensen er lille eller stor, så vælger vi i stedet at se på den kvadrerede forskel:</p>
<p><span class="math display">\[
\left ( t - \left ( w_0 + w_1 \cdot x_1 + w_2 \cdot x_2 + \cdots + w_n \cdot x_n \right ) \right )^2
\]</span></p>
<p>Vi får en sådan kvadreret differens for hvert eneste hus i vores træningsdatasæt, og vi vælger derfor blot at lægge alle disse størrelser sammen:</p>
<p><span class="math display">\[
E = \frac{1}{2}\sum \left ( t - \left ( w_0 + w_1 \cdot x_1 + w_2 \cdot x_2 + \cdots + w_n \cdot x_n \right ) \right )^2
\]</span></p>
<p>Størrelsen <span class="math inline">\(E\)</span> kaldes for en <strong>tabsfunktion</strong>. Læg mærke til, at hvis vores kunstige neuron er god til at forudsige huspriser, så får vi en lille værdi af tabsfunktionen, mens vi får en stor værdi af E, hvis modellen er dårlig til at forudsige huspriser. Vi har her valgt at gange med <span class="math inline">\(\frac{1}{2}\)</span>, fordi det senere kommer til at forkorte ud, men det er faktisk ikke så afgørende.</p>
<p>Idéen er så bare at bestemme værdier af vægtene <span class="math inline">\(w_0, w_1, w_2, \dots, w_n\)</span>, sådan at tabsfunktionen minimeres.</p>
<p>Inden vi forklarer, hvordan det gøres, så lad os lige blive lidt mere specifikke i forhold til notationen af vores træningsdata. Vi forestiller os, at vi har information om <span class="math inline">\(M\)</span> huspriser. Så vil vi nummerer vores træningsdata på denne måde:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\text{Træningseksempel 1:} \quad (x_1^{(1)}, x_2^{(1)}, \dots, x_n^{(1)}, t^{(1)}) \\
&amp;  \quad \quad \quad \quad \vdots \\
&amp;\text{Træningseksempel m:} \quad (x_1^{(m)}, x_2^{(m)}, \dots, x_n^{(m)}, t^{(m)}) \\
&amp;  \quad \quad \quad \quad \vdots \\
&amp;\text{Træningseksempel M:} \quad (x_1^{(M)}, x_2^{(M)}, \dots, x_n^{(M)}, t^{(M)}) \\
\end{aligned}
\]</span></p>
<p>Gør vi det, bliver tabsfunktionen:</p>
<p><span class="math display">\[
\begin{aligned}
E(w_0, w_1, &amp;\dots, w_n) \\ &amp;= \frac{1}{2} \sum_{m=1}^{M} \left (t^{(m)}-
(w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}) \right)^2.
\end{aligned}
\]</span></p>
<p>Hvis vi samtidig indfører, at vi kalder outputværdien for det <span class="math inline">\(m\)</span>’te træningseksempel for <span class="math inline">\(o^{(m)}\)</span>:</p>
<p><span class="math display">\[
o^{(m)} = w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}
\]</span> Så kan tabsfunktionen udtrykkes kort på denne måde:</p>
<p><span class="math display">\[
\begin{aligned}
E(w_0, w_1, &amp;\dots, w_n) \\ &amp;= \frac{1}{2} \sum_{m=1}^{M} \left (t^{(m)}-
o^{(m)} \right)^2
\end{aligned}
\]</span></p>
<p>hvor det nu så bare ikke er helt så tydeligt, at <span class="math inline">\(E\)</span> jo faktisk afhænger af alle vægtene.</p>
<p>For at bestemme de værdier af vægtene, som minimerer tabsfunktionen, vil vi bruge en metode, som kaldes for gradientnedstigning. Vi har lavet videoer om både <a href="https://youtu.be/tlq2UYWF2Rw" target="blank">funktioner af to variable</a> og <a href="https://youtu.be/WcM8aEoPzf8" target="blank">gradientnedstigning</a>, hvis du vil vide mere.</p>
<p>Idéen i gradientnedstigning er, at vi opdaterer alle vægtene ved at gå et lille stykke i den negative gradients retning. Det kommer til at se sådan her ud:</p>
<p><span class="math display">\[
\begin{aligned}
w_0^{(\textrm{ny})} \leftarrow &amp; w_0 - \eta \cdot \frac{\partial E }{\partial w_0} \\
w_1^{(\textrm{ny})} \leftarrow &amp; w_1 - \eta \cdot \frac{\partial E }{\partial w_1} \\
&amp;\vdots  \\
w_n^{(\textrm{ny})} \leftarrow &amp; w_n - \eta \cdot \frac{\partial E }{\partial w_n} \\
\end{aligned}
\]</span></p>
<p>hvor <span class="math inline">\(\eta\)</span> kaldes for en <strong>learning rate</strong>.</p>
<p>Vi får derfor brug for alle de partielle afledede af <span class="math inline">\(E\)</span> med hensyn til <span class="math inline">\(w_i\)</span> for <span class="math inline">\(i \in \{0, 1, 2, \dots, n\}\)</span>. Det er ikke svært at vise, at</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial E}{\partial w_i} &amp;= - \sum_{m=1}^M \left (t^{(m)}-
(w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}) \right) \cdot x_i^{(m)} \\
&amp;= - \sum_{m=1}^M \left (t^{(m)}- o^{(m)} \right) \cdot x_i^{(m)}
\end{aligned}
\]</span> for <span class="math inline">\(i \in \{1, 2, \dots, n\}\)</span> og</p>
<p><span class="math display">\[
\frac{\partial E}{\partial w_0} = - \sum_{m=1}^M \left (t^{(m)}- o^{(m)} \right)
\]</span> Opdateringsreglerne for vægtene bliver derfor:</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Opdateringsregler for kunstige neuroner til regression
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p><span class="math display">\[
\begin{aligned}
w_0^{(\textrm{ny})} \leftarrow &amp; w_0 + \eta \cdot \sum_{m=1}^{M} \left (t^{(m)}-o^{(m)} \right)\\
w_1^{(\textrm{ny})} \leftarrow &amp; w_1 + \eta \cdot \sum_{m=1}^{M} \left (t^{(m)}-o^{(m)} \right)\cdot x_1^{(m)}\\
&amp;\vdots  \\
w_n^{(\textrm{ny})} \leftarrow &amp; w_n + \eta \cdot \sum_{m=1}^{M} \left (t^{(m)}-o^{(m)} \right)\cdot x_n^{(m)}
\end{aligned}
\]</span></p>
<p>hvor <span class="math inline">\(o^{(m)} = w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}\)</span>.</p>
</div>
</div>
</div>
<p>At opstille en kunstig neuron til regression, som vi har gjort her, svarer til det man kalder for <strong>multipel lineær regression</strong>, som egentlig bare er en udvidelse af lineær regression, som I kender det, blot med flere inputvariable.</p>
<p>Det gode ved at opstille en kunstig neuron til regression, som vi her har gjort det, er, at man kan give en fortolkning af vægtene.</p>
<section id="fortolkning-af-vægtene" class="level3">
<h3 class="anchored" data-anchor-id="fortolkning-af-vægtene">Fortolkning af vægtene</h3>
<p>Lad os sige, at vi har bestemt vægtene <span class="math inline">\(w_0, w_1, \dots, w_n\)</span>, så tabsfunktionen er blevet minimeret, og at <span class="math inline">\(X_1\)</span> fortsat angiver boligarealet. Vi vil her forklare, hvordan vi kan fortolke <span class="math inline">\(w_1\)</span>.</p>
<p>Vi forstiller os, at vi har to hus med præcis samme værdier af de <span class="math inline">\(n\)</span> inputvariable <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> bortset fra, at det ene hus er pris <span class="math inline">\(1\)</span> kvadratmeter større end det andet. Så det ene hus har en størrelse på <span class="math inline">\(x_1\)</span> kvadratmeter, mens det andet har en størrelse på <span class="math inline">\(x_1+1\)</span> kvadratmeter – de resterende inputvariable er ens.</p>
<p>Det giver følgende prædikterede boligpriser <span class="math inline">\(o_1\)</span> og <span class="math inline">\(o_2\)</span> for de to huse:</p>
<p><span class="math display">\[
\begin{aligned}
o_1 &amp;= w_0 + w_1 \cdot x_1 + w_2 \cdot x_2 + \cdots + w_n \cdot x_n \\
\\
o_2 &amp;= w_0 + w_1 \cdot (x_1 + 1) + w_2 \cdot x_2 + \cdots + w_n \cdot x_n \\
&amp;= w_0 + w_1 \cdot x_1 + w_1 + w_2 \cdot x_2 + \cdots + w_n \cdot x_n
\end{aligned}
\]</span></p>
<p>Da bliver forskellen mellem de to prædikterede boligpriser:</p>
<p><span class="math display">\[
\begin{aligned}
o_2 - o_1 &amp;= w_0 + w_1 \cdot x_1 + w_1 + w_2 \cdot x_2 + \cdots + w_n \cdot x_n \\
&amp; \quad \quad - \left ( w_0 + w_1 \cdot x_1 + w_2 \cdot x_2 + \cdots + w_n \cdot x_n \right) \\
&amp;= w_0 + w_1 \cdot x_1 + w_1 + w_2 \cdot x_2 + \cdots + w_n \cdot x_n \\ &amp; \quad \quad - w_0 - w_1 \cdot x_1 - w_2 \cdot x_2 - \cdots - w_n \cdot x_n \\
&amp; = w_1
\end{aligned}
\]</span></p>
<p>Det vil sige, at hvis alt andet er holdt ens, så vil en forøgelse i boligarelet på én kvadratmeter give en forøgelse i den prædikterede boligpris på <span class="math inline">\(w_1\)</span> kroner.</p>
<p>Hvis <span class="math inline">\(x_2\)</span> angiver, om boligen har kælder eller ej (hvor <span class="math inline">\(x_2=1\)</span> svarer til at boligen har kælder og <span class="math inline">\(x_2=0\)</span> svarer til at boligen ikke har kælder), så vil <span class="math inline">\(w_2\)</span> helt tilsvarende kunne fortolkes som den størrelse den prædikterede boligpris vil stige med, hvis en bolig har kælder sammenlignet med en helt tilsvarende bolig uden kælder.</p>
<p>Vi illustrerer dette med et eksempel:</p>
</section>
</section>
<section id="fortolkning-af-vægtene-1" class="level2 {exm-kunstig_neuron_regression}">
<h2 class="anchored" data-anchor-id="fortolkning-af-vægtene-1">Fortolkning af vægtene</h2>
</section>
<section id="prædiktion-af-huspriser-nu-med-skjulte-lag" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="prædiktion-af-huspriser-nu-med-skjulte-lag">Prædiktion af huspriser – nu med skjulte lag!</h2>
<p>Der skal helst ikke være skjulte fejl og mangler, når man skal sælge sit hus. Til gengæld kan det være en super god idé med nogle skjulte lag, når man skal prædiktere huspriser!</p>
<p>I det ovenstående kommer de prædikterede huspriser til at afhænge lineært af inputvariablene. Men verden er sjældent lineær! Og en af styrkerne ved kunstige neurale netværk er netop, at de kan prædiktere størrelse eller kategorier ved hjælp af funktioner, som ikke er lineære. Vi skal derfor nu opstille et simpelt kunstigt neuralt netværk til prædiktion af huspriser. Vi vil lave et netværk igen med <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> som inputvariable, men nu med et såkaldt skjult lag, som består af to neuroner. Det kan illustreres, som vist i <a href="#fig-neuralt_net_regression" class="quarto-xref">figur&nbsp;1</a>:</p>
<div id="fig-neuralt_net_regression" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-neuralt_net_regression-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/neuralt_net_regression.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-neuralt_net_regression-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;1: Simpelt kunstigt neuralt netværk til prædiktion af huspriser. Netværket har inputvariable <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> og ét skjult lag med to neuroner.
</figcaption>
</figure>
</div>
<p>Hvis vi for en stund forestiller os, at vi kender alle vægtene, så udregner vi outputværdien <span class="math inline">\(o\)</span> på følgende måde:</p>
<p>Ved hjælp af inputvariablene og <span class="math inline">\(v\)</span>-vægtene beregner vi <span class="math inline">\(z_1\)</span>:</p>
<p><span class="math display">\[
z_1 = \sigma (v_0 + v_1 \cdot x_1 + \cdots + v_n \cdot x_n)
\]</span></p>
<p>Her er <span class="math inline">\(\sigma(x)\)</span> <strong>sigmoid-funktionen</strong> med forskrift</p>
<p><span id="eq-sigmoid"><span class="math display">\[
\sigma(x)=\frac{1}{1+\mathrm{e}^{-x}}
\tag{1}\]</span></span></p>
<p>og grafen ses i <a href="#fig-sigmoid" class="quarto-xref">figur&nbsp;2</a>.</p>
<div id="fig-sigmoid" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../kunstige_neuroner/images/sigmoid.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;2: Grafen for sigmoid-funktionen med forskrift <span class="math inline">\(\sigma(x)=\frac{1}{1+\mathrm{e}^{-x}}\)</span>.
</figcaption>
</figure>
</div>
<p>Sigmoid-funktionen kaldes også for en <strong>aktiveringsfunktion</strong>, og det er den, der gør, at vi ender med at prædiktere huspriserne på en ikke-lineær måde.</p>
<p>På tilsvarende vis udregner vi <span class="math inline">\(z_2\)</span> ved at bruge <span class="math inline">\(u\)</span>-vægtene:</p>
<p><span class="math display">\[
z_2 = \sigma (u_0 + u_1 \cdot x_1 + \cdots + u_n \cdot x_n)
\]</span></p>
<p>Når vi nu har <span class="math inline">\(z_1\)</span> og <span class="math inline">\(z_2\)</span> beregnes outputværdien <span class="math inline">\(o\)</span> som vi gjorde det tidligere:</p>
<p><span class="math display">\[
o = w_0 + w_1 \cdot z_1 + w_2 \cdot z_2
\]</span></p>
<p>Ovenstående udtryk for beregning af <span class="math inline">\(z_1\)</span>, <span class="math inline">\(z_2\)</span> og <span class="math inline">\(o\)</span> kaldes for <strong>feedforward</strong> ligninger, fordi man laver beregninger "fremad" i netværket fra venstre mod højre. Hvis vi samtidig holder styr på hvilket træningseksempel vi står med, får vi følgende:</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Feedforward-udtryk
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>På baggrund af inputværdierne <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> beregnes outputværdien <span class="math inline">\(o\)</span> på følgende måde.</p>
<p>Først beregnes:</p>
<p><span id="eq-z_1"><span class="math display">\[
z_1^{(m)} = \sigma \left (v_0 + v_1 \cdot x_1^{(m)} + \cdots + v_n \cdot x_n^{(m)} \right)
\tag{2}\]</span></span></p>
<p>og</p>
<p><span id="eq-z_2"><span class="math display">\[
z_2^{(m)} = \sigma \left (u_0 + u_1 \cdot x_1^{(m)} + \cdots + u_n \cdot x_n^{(m)} \right)
\tag{3}\]</span></span></p>
<p>Herefter beregnes outputværdien:</p>
<p><span id="eq-o"><span class="math display">\[
o^{(m)} = w_0 + w_1 \cdot z_1^{(m)} + w_2 \cdot z_2^{(m)}
\tag{4}\]</span></span></p>
</div>
</div>
</div>
<p>Tabsfunktionen definerer vi nu som før</p>
<p><span class="math display">\[
\begin{aligned}
E(w_0, w_1, &amp;\dots, w_n) \\ &amp;= \frac{1}{2} \sum_{m=1}^{M} \left (t^{(m)}-
o^{(m)} \right)^2
\end{aligned}
\]</span></p>
<p>hvor <span class="math inline">\(o^{(m)}\)</span> er givet ved udtrykket i (<a href="#eq-o" class="quarto-xref">4</a>).</p>
<p>Man kan nu igen bruge gradientnedstigning til at bestemme de værdier er <span class="math inline">\(v\)</span>-, <span class="math inline">\(u\)</span>- og <span class="math inline">\(w\)</span>-vægtene, som minimerer tabsfunktionen. Det er her en vigtig beregningsfinte, at man bevæger sig "bagud" i netværket og først opdaterer <span class="math inline">\(w\)</span>-vægtene (som er tættest på outputlaget) og dernæst <span class="math inline">\(u\)</span>- og <span class="math inline">\(v\)</span>-vægtene, som er tættest på inputlaget. Dette kaldes for <strong>backpropagation</strong>.</p>
<p>Gør man det ender, man med følgende opdateringsregler:</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Backpropagation
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Backpropagation foregår samlet set på denne måde:</p>
<ol type="1">
<li><p>Sæt alle vægtene til en tilfældig værdi og vælg en værdi for learning raten <span class="math inline">\(\eta\)</span>.</p></li>
<li><p>For alle træningsdataeksempler udregnes <span class="math inline">\(z_1^{(m)}\)</span>, <span class="math inline">\(z_2^{(m)}\)</span> og <span class="math inline">\(o^{(m)}\)</span> ved hjælp af feedforward-udtrykkene:</p>
<p><span class="math display">\[
\begin{aligned}
z_1^{(m)} &amp;= \sigma \left (v_0 + v_1 \cdot x_1^{(m)} + \cdots + v_n \cdot x_n^{(m)} \right ) \\
z_2^{(m)} &amp;= \sigma \left (u_0 + u_1 \cdot x_1^{(m)} + \cdots + u_n \cdot x_n^{(m)} \right ) \\
o^{(m)} &amp;= w_0 + w_1 \cdot z_1^{(m)} + w_2 \cdot z_2^{(m)}
\end{aligned}
\]</span></p></li>
<li><p>Vægtene opdatereres:</p>
<p><strong><span class="math inline">\(w\)</span>-vægtene:</strong> <span class="math display">\[
\begin{aligned}
w_0^{\textrm{(ny)}} &amp;\leftarrow w_0 + \eta \cdot \sum_{m=1}^{M} \left ( t^{(m)}-o^{(m)}\right) \\
w_1^{\textrm{(ny)}} &amp;\leftarrow w_1 + \eta \cdot \sum_{m=1}^{M} \left ( t^{(m)}-o^{(m)}\right) \cdot z_1^{(m)} \\
w_2^{\textrm{(ny)}} &amp;\leftarrow w_2 + \eta \cdot \sum_{m=1}^{M} \left ( t^{(m)}-o^{(m)}\right) \cdot z_2^{(m)}
\end{aligned}
\]</span> <strong><span class="math inline">\(v\)</span>-vægtene:</strong> <span class="math display">\[
\begin{aligned}
v_0^{\textrm{(ny)}} &amp;\leftarrow v_0 + \eta \cdot \sum_{m=1}^{M} \left ( t^{(m)}-o^{(m)}\right) \cdot w_1 \cdot z_1^{(m)} \cdot \left ( 1- z_1^{(m)} \right) \\
v_i^{\textrm{(ny)}} &amp;\leftarrow v_i + \eta \cdot \sum_{m=1}^{M} \left ( t^{(m)}-o^{(m)}\right) \cdot w_1 \cdot z_1^{(m)} \cdot \left ( 1- z_1^{(m)} \right) \cdot x_i^{(m)}\\
\end{aligned}
\]</span> for <span class="math inline">\(i \in \{1, 2, 3, 4\}\)</span>.</p>
<p><strong><span class="math inline">\(u\)</span>-vægtene:</strong> <span class="math display">\[
\begin{aligned}
u_0^{\textrm{(ny)}} &amp;\leftarrow u_0 + \eta \cdot \sum_{m=1}^{M} \left ( t^{(m)}-o^{(m)}\right) \cdot w_2 \cdot z_2^{(m)} \cdot \left ( 1- z_2^{(m)} \right) \\
u_i^{\textrm{(ny)}} &amp;\leftarrow u_i + \eta \cdot \sum_{m=1}^{M} \left ( t^{(m)}-o^{(m)}\right) \cdot w_2 \cdot z_2^{(m)} \cdot \left ( 1- z_2^{(m)} \right) \cdot x_i^{(m)}\\
\end{aligned}
\]</span> for <span class="math inline">\(i \in \{1, 2, 3, 4\}\)</span>.</p>
<p>Bemærk her, at vi kender <span class="math inline">\(z_1^{(m)}\)</span>, <span class="math inline">\(z_2^{(m)}\)</span> og <span class="math inline">\(o^{(m)}\)</span> på grund af feedforward, mens alle <span class="math inline">\(u\)</span>-, <span class="math inline">\(v\)</span>- og <span class="math inline">\(w\)</span>-værdierne er de nuværende værdier af vægtene (<em>inden</em> opdatering).</p></li>
</ol>
<p>Alle vægtene er nu opdateret, og vi kan gentage punkt 2 til 3, hvor feedforward i 2 hver gang er baseret på de netop opdaterede vægte fra det foregående gennemløb. Opdateringen af vægtene fortsætter indtil værdien af tabsfunktionen næsten ikke ændrer sig. Håbet er nu, at vi har fundet et minimum (eventuelt kun lokalt) for tabsfunktionen.</p>
</div>
</div>
</div>
<p>Ser vi på opdateringsreglerne for <span class="math inline">\(w\)</span>-vægtene, kan vi se, at der i alle regler indgår en faktor</p>
<p><span class="math display">\[
\left ( t^{(m)}-o^{(m)}\right)
\]</span></p>
<p>som er et udtryk for den fejl netværket begår med de nuværende værdier af vægtene (nemlig forskellen på den ønskede targetværdi <span class="math inline">\(t^{(m)}\)</span> og den prædikterede outputværdi <span class="math inline">\(o^{(m)}\)</span>). Der er to ting, som er værd at bemærke i den forbindelse:</p>
<ul>
<li>Hvis fejlen er stor, bliver <span class="math inline">\(w\)</span> vægtene opdateret forholdsvis meget – og omvendt hvis fejlen er lille.</li>
<li>Når vi har opdateret <span class="math inline">\(w\)</span>-vægtene, har vi allerede beregnet fejlen <span class="math inline">\(t^{(m)}-o^{(m)}\)</span>. Denne "fejlfaktor" indgår også i opdateringsreglerne for <span class="math inline">\(v\)</span>- og <span class="math inline">\(u\)</span>-vægtene og den allerede beregnede fejl kan altså genbruges, når <span class="math inline">\(v\)</span>- og <span class="math inline">\(u\)</span>-vægtene skal opdateres.</li>
</ul>
<p>Det kan her virke fuldstændig ligegyldigt, om vi skal beregne fejlen et par ekstra gange eller ej, men i virkelighedens anvendelser af kunstige neurale netværk, er det lige præcis denne beregningsmæssige finte, som gør, at det overhovedet kan lade sig gøre at bruge gradientnedstigning!</p>
<p>Hvis du gerne vil bevise ovenstående, er der lidt hjælp at hente i nedenstående boks.</p>
<div class="callout callout-style-simple callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Hjælp til at udlede opdateringsreglerne
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Husk på, at vores tabsfunktion ser sådan her ud:</p>
<p><span class="math display">\[
\begin{aligned}
E(w_0, w_1, \dots, w_n) &amp;= \frac{1}{2} \sum_{m=1}^{M} \left (t^{(m)}-
o^{(m)} \right)^2 \\
&amp;=\frac{1}{2} \sum_{m=1}^{M} \left (t^{(m)}-
(w_0 + w_1 \cdot z_1^{(m)} + w_2 \cdot z_2^{(m)}) \right)^2.
\end{aligned}
\]</span></p>
<p>Når du skal bestemme</p>
<p><span class="math display">\[
\frac{\partial E}{\partial w_i},
\]</span></p>
<p>så skal du gøre fuldstændig, som vi gjorde i afsnittet <a href="#hvad-koster-mit-hus">Hvad koster mit hus?</a></p>
<p>Når du skal finde</p>
<p><span class="math display">\[
\frac{\partial E}{\partial v_i},
\]</span></p>
<p>Da <span class="math inline">\(v_i\)</span> kun har indflydelse på <span class="math inline">\(E\)</span> via <span class="math inline">\(z_1^{(m)}\)</span>-værdierne, behøver vi heldigvis ikke kædereglen for funktioner af flere variable. Men kædereglen får vi brug for – du kan eventuelt se <a href="https://www.youtube.com/watch?v=nVaAIVXiUjs">denne video om kædereglen</a>, hvis du vil forstå nedenstående notation lidt bedre. Vi får nemlig (hvor vi også lige har brugt sumreglen):</p>
<p><span class="math display">\[
\frac{\partial E}{\partial v_i} = \sum_{m=1}^M \frac{\partial E}{\partial z_1^{(m)}} \cdot \frac{\partial z_1^{(m)}}{\partial v_i}
\]</span></p>
<p>Når <span class="math inline">\(z_1^{(m)}\)</span> skal differentieres med hensyn til <span class="math inline">\(v_i\)</span> får vi brug for en særlig egenskab ved sigmoid-funktionen. Nemlig, at</p>
<p><span class="math display">\[
\sigma'(x) = \sigma(x) \cdot (1-\sigma(x))
\]</span> Tilsvarende er</p>
<p><span class="math display">\[
\frac{\partial E}{\partial u_i} = \sum_{m=1}^M \frac{\partial E}{\partial z_2^{(m)}} \cdot \frac{\partial z_2^{(m)}}{\partial u_i}
\]</span></p>
</div>
</div>
</div>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/aimat\.dk");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><img src="../../logo/SVG/Bomaerke_03_AIMAT_2024.svg" class="footer-logo"> aimat.dk er finansieret af Novo Nordisk Fonden</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>
<script src="../../scripts/navbar-tooltips.js"></script>




</body></html>