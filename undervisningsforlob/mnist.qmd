---
title: "Kan vi genkende håndskrevne tal?"
description-meta: "Hvordan får man en computer til at genkende håndskrevne tal? I dette forløb skal vi se på, hvordan man ud fra et billede af et håndskrevet tal kan lave en algortime, som kan genkende tallet."
image: "mnist_filer/.png"
categories:
  - C-niveau
  - Kort
  - Informatik
---

::: {.callout-caution collapse="true" appearance="minimal"}
### Forudsætninger og tidsforbrug
Forløbet kræver kendskab til:

+ Deskriptiv statistik.
+ Koordinatsystemer.
+ Rette linjer.

**Tidsforbrug:** Ca. 90 minutter.

:::


::: {.purpose}

### Formål

Nogle gange har man brug for, at håndskreven tekst kan digitaliseres. Det kan for eksempel være i en eksamenssituation, hvor din lærer og censor skriver din karakter på en liste, som efterfølgende skal tastes ind på en computer. Det ville være smart, hvis man kunne scanne listen eller tage et billede af den, hvorefter alle tal korrekt vil blive genkendt (så du ikke får en forkert karakter!). Dette forløb handler om, hvordan det kan gøres. 

:::

## RGB-farvemodellen

Vi skal først se lidt på, hvordan billeder bliver repræsenteret i en computer. Prøv at finde et billede på din computer og zoom ind så meget som muligt. Du vil opdage, at billedet i virkeligheden består en masse små kvadrater, som hver især har én farve. Sådan et kvadrat kaldes for en **pixel**.

Hver pixel består af tre **subpixels**. Den første subpixel kan lyse **R**ød, den anden **G**røn og den trejde **B**lå:

![Subpixel.](mnist_filer/subpixel.png){#fig-subpixel width=10% fig-align="center"}

Fordi alle farver bliver repræsenteret ved disse tre farver, taler man om en **RGB**-farvemodel.

Vi kan skrue på lysstyrken i hver af de tre subpixels. Hvis der er skruet fuldt op for farven, er værdien 255, mens helt slukket svarer til værdien[^1] 0.

[^1]: Tallene fra 0 til 255 kan i det binære talsystem repræsenteres ved 8 bits svarende til 1 byte.

Vores øje opfatter ikke farven på de tre subpixels individuelt, men vi vil i stedet se en blandingsfarve. Hvis der for eksempel er skruet fuldt op på alle tre farver, så vil vores øje opfatte det som hvid. Det vil sige, at den pixel, som er vist i @fig-subpixel lyser hvid for os!

Skruer vi helt op for rød og blå, men slukker for grøn fås en pink farve (som kaldes for magenta):

![Farven magenta - repræsenteret ved rgb(255,0,255).](mnist_filer/magenta.png){#fig-magenta width=10% fig-align="center"}


Farven skrives:

::: {.centertext}
rgb(255,0,255)
:::

Hvis der er skruet lige meget op for den røde, grønne og blå subpixel, fås forskellige nuancer af grå. Det er der vist eksempler på her:

![Forskellige toner af grå.](mnist_filer/grays.png){#fig-grays width=30% fig-align="center"}


Det betyder, at hvis man udelukkende er interesseret i gråskalaværdier, så kan vi nøjes med én værdi, som er den fælles værdi for rød, grøn og blå:


![Forskellige toner af grå repræsenteret ved én værdi.](mnist_filer/grays2.png){#fig-grays width=30% fig-align="center"}

## MNIST datasættet

Der findes et stort datasæt -- det såkaldte [MNIST[^2] datasæt](https://www.kaggle.com/datasets/oddrationale/mnist-in-csv?resource=download), hvor man har samlet 60000 håndskrevne cifre. Datasættet består af 60000 rækker, som hver repræsenterer et håndskrevet ciffer mellem $0$ og $9$. Der er i alt 785 kolonner. Den første kolonne kaldet \"label\" angiver hvilket ciffer, der er tale om. Det er den værdi, som vi i sidste ende gerne vil kunne forudsige. En sådan værdi kaldes også for en **targetværdi**. De resterende 784 kolonner angiver gråskalaværdierne fra et $28 \times 28$ pixel billede af et håndskrevet ciffer.

[^2]: MNIST står for \"Modified National Institute of Standards\".


På @fig-mnist0_original ses et håndskrevet \"0\" fra MNIST datasættet. 

![Et håndskrevet \"0\" fra MNIST datasættet.](mnist_filer/mnist_0_white_on_black.png){#fig-mnist0_original width=30% fig-align="center"}

Bemærk, at der er skrevet med hvid på sort baggrund. Når vi i det følgende viser billederne af de håndskrevne tal, har vi valgt at vende farveskalaen om, så vi i stedet for gråskalaværdien $x$ tegner en pixel med gråskalaværdi

$$
255-x
$$

Det betyder, at vi i stedet for sort viser hvid og omvendt. Dette er illustreret på @fig-mnist0.

![Et håndskrevet \"0\" fra MNIST datasættet, men hvor farveskalaen er vendt om.](mnist_filer/mnist_0_black_on_white.png){#fig-mnist0 width=30% fig-align="center"}


Vi skal nu prøve, om vi ud fra de 784 gråskalaværdier kan \"udvinde\" nogle få, men sigende værdier, som kan bruges til at forudsige, hvilket ciffer der er på billedet. I første omgang vil vi prøve, om vi kan kende forskel på 0- og 1-taller.

Det første, vi vil gøre, er at lave billederne i en lavere opløsning svarende til, at billederne bliver mere pixeleret. Vi vil for eksempel lave et $7 \times 7$ pixel billede ved at inddele det oprindelige $28 \times 28$ pixel billede i $2 \times 2$ pixels, hvor vi så tager gennemsnittet af de pixelværdien. Et eksempel på det ses i @fig-pixeleret0:

![Et billede af et 0 med en oprindelige opløsning på $28 \times 28$ pixels og det samme billede i en opløsning på $7 \times 7$ pixels.](mnist_filer/pixeleret0.png){#fig-pixeleret0 width=80% fig-align="center"}

Til trods for at billedet er meget mere pixeleret, kan man faktisk stadigvæk tydeligt se konturerne af 0'et. Til sammenligning er et billede af et 1-tal vist i @fig-pixeleret1:

![Et billede af 1 med en oprindelige opløsning på $28 \times 28$ pixels og det samme billede i en opløsning på $7 \times 7$ pixels.](mnist_filer/pixeleret1.png){#fig-pixeleret1 width=80% fig-align="center"}

## Kan vi kende forskel på 0 og 1?

Idéen er, som nævnt tidligere, at vi ud fra $7 \times 7$ billederne vil udvinde nogle nye og få værdier, som kan bruges til at kende forskel på $0$- og $1$-tallerne. Vi vil altså gerne koge de ialt 49 pixelværdier ned til en til tre værdier, som er nok til at adskille 0 fra 1. Sådanne værdier kaldes for **features**.


::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 1: Beregning af featuers

Det kunne godt se ud som om, at der bruges flere farvede pixels på at skrive et 0, end der bliver brugt på at skrive et 1-tal. Vi vil derfor helt enkelt udregne den gennemsnitlige pixelværdi af hele billedet.

* Udregne den gennemsnitlige pixelværdi for nedenstående to billeder:

![](mnist_filer/pixel_gns.png){width=80% fig-align="center"}

Et andet bud på en feature er helt enkelt, hvor mange pixels, der er helt hvide (det vil her sige med en pixelværdi på 0). Vi vil nemlig forvente, at et 1-tal fylder mindre end et 0, så antallet af helt hvide pixels må forventes at være større på billederne af 1-taller.

* Tæl antallet at hele hvide pixels på ovenstående to billeder.

* Vi har nu beregnet to forskellige features for de to billeder. Er værdierne som forventet?

* Det er klart, at den gennemsnitlige pixelværdi og antallet af helt hvide pixels hænger sammen. Forklar med ord hvilken sammenhæng, man vil forvente.

:::

Det bliver selvfølgelig lidt møjsommeligt at udregne disse to features for mange billeder. Derfor skal vi nu bruge en app, som gør arbejdet for dig.


::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 2: MNIST datasættet

[Åbn denne app](https://apps01.math.aau.dk/ai/cifre/){target="_blank"}. 

Øverst kan du vælge hvilket ciffer fra MNIST datasættet, du vil se. Dernæst kan du vælge pixelopløsning ($7 \times 7$, $14 \times 14$ eller det oprindelige $28 \times 28$). Herefter kan du vælge, om du vil have vist pixelværdierne på det pixelerede billede eller ej. Endelig kan du trykke på \"Forrige billede\" eller \"Næste billede\" for at bladre i de forskellige billeder fra MNIST datasættet. 

* Start med at bladre lidt rundt blandt de forskellige cifre, så du får et indtryk af datasættet.

I tabellen under det oprindelige billede, kan du se de to features \"pixel_gns\" og \"antal_tomme\", som er de to features, du udregnede i opgave 1.

* Det første 0 (med et id på 0) og det første 1-tal (med id på 100) svarer til de to billeder, som du regnede på i opgave 1. Kontrollér, om du har regnet rigtigt!

:::


::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 3: Download af datasæt

Vi skal nu have downloadet et datasæt, hvor disse to features er udregnet for i alt 100 billeder af henholdsvis 0 og 1-taller.

Gå til fanen \"Download\". Her vælger du:

- En pixelopløsning på 7.
- Sæt flueben ved 0 og 1.
- Under \"Hele billedet\" sætter du flueben både ved \"Gennemsnit\" og \"Antal tomme pixel\".
- Resten af fluebenene fjerner du.
- Tryk på \"Download data\".

:::

Når du åbner datasættet i Excel, skulle det gerne se sådan her ud:

![](mnist_filer/eks_excel.png){width=60% fig-align="center"}

Den første kolonne (\"label\") angiver, om der er tale om et billede af et 0 eller et 1-tal. Den anden kolonne (\"id\") er billedets id (det kan du bruge til at få vist billedet i app'en), de to sidste kolonner (\"pixel_gns\") og (\"antal_tomme\") svarer til de features, som vi beregnede i opgave 1.

::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 4: Boksplots

Vi vil starte med at undersøge de to features hver for sig.

- Tegn i samme figur et boksplot af \"pixel_gns\" for både 0 og 1.

- Forklar niveau- og spredningsforskelle i de to boksplots.

- Gentag ovenstående, men for \"antal_tomme\".

- Vil man kunne bruge enten \"pixel_gns\" eller \"antal_tomme\" alene til at kende forskel på 0 og 1?

:::

::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 5: Plot af to features

+ Lav et punktplot med \"pixel_gns\" ud af $x$-aksen og \"antal_tomme\" op af $y$-aksen. Sørg for at alle punkter, som svarer til billeder af 0'er er farvet røde og alle punkter, som svarer til billeder af 1-taller er farvet blå.

<details>
<summary> Sådan gør du i GeoGebra </summary>

Åbn datasættet i Excel og kopiere det hele over i et \"Regneark\" i GeoGebra (tryk på \"Vis\" $\rightarrow$ \"Regneark\").


+ Stil dig i celle `E2` (det skulle gerne være den første tomme celle i anden række).
+ Skriv `(C2,D2)` (det skulle give dig værdien for \"pixel_gns\" og \"antal_tomme\" for det første billede).
+ Markér cellen. Tag ved den lille firkant nederst til højre og træk ned, så du får punkter for alle 200 billeder.
+ Justér på akserne på tegneblokken, så du kan se alle punkterne. Markér alle punkterne, højreklikke og trykke på \"Basis\". Sæt flueben ved \"Fast objekt\" (det sikrer, at du ikke ved en fejl kan flytte på punkterne). *Hvis* der er vist et navn ved punkterne i tegneblokken,  fjerner du også fluebenet ved \"Vis navn\".
+ Markér alle de punkter i regnearket, som har en \"label\" værdi på 0. Højreklik og vælg \"Egenskaber\". Under fanen \"Farve\" vælger du rød.
+ Farv på tilsvarende måde alle punkterne med en \"label\" værdi på 1 blå.
+ Højreklik på tegneblokken og vælg \"Tegneblok\". Gå ind under fanen \"xAkse\". Under \"Navn\" skriver du \"pixel gns\" og tilsvarende navngiver du $y$-aksen \"antal tomme\".

</details>

:::

::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 6: Klassifikation baseret på en eller to features

Vi vil starte med at undersøge, om vi kan kende forskel på 0 og 1 alene baseret på én af de to features.

**Gennemsnitlig pixelværdi**

+ Indtegn en lodret linje ved for eksempel at skrive $x=20$. Hvilken lodret linje er bedst til at adskille de blå punkter fra de røde?

+ Hvor mange punkter kommer som minimum til at ligge på den forkerte side af linjen?

+ Find id'et på de punkter, som ligger på den forkerte side af linjen. Man siger, at disse punkter er blevet klassificeret forkert. Brug app'en til at få vist et billede af disse tal. Kan du forklare, hvorfor disse billeder bliver klassificeret forkert, når vi ser på pixel gennemsnittet alene?

Klassifikationsnøjagtigheden (**CA** for *classification accuracy* på engelsk) angiver hvor stor en procentdel af data, som er blevet klassificeret korrekt.

+ Udregn klassifikationsnøjagtigheden.

**Antal hvide pixels**

Vi vil nu undersøge, hvor mange billeder vi kan klassificere korrekt, ved kun at se på antallet af hvide pixels i billedet.

+ Indtegn en vandret linje ved for eksempel at skrive $y=20$.

+ Svar på de samme spørgsmål som ovenfor, men nu baseret på den vandrette linje.

**Begge features**

Til sidst vil vi prøve at undersøge, om vi kan gøre det bedre ved at bruge begge features.

+ Indtegn en ret linje i koordinatsystemet.

+ Svar på de samme spørgsmål som ovenfor, men nu baseret på den generelle rette linje.

:::

I opgave 6 ovenfor kom du formentlig frem til, at hvis vi alene skal adskille 0'er fra 1-taller, så er det faktisk nok at tælle antallet af hvide pixels i billedet! Gør vi det, kan vi med vores træningsdata få en klassifikationsnøjagtighed på $98.5\%$.

::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 7: Hjælper det med højere opløsning? (valgfri)

+ Undersøg, om du kan få en højere klassifikationsnøjagtighed ved at bruge en pixelopløsning på $14 \times 14$ eller $28 \times 28$ pixels.

:::

## Kan vi kende forskel på 0 og 3?

Det går jo strygende! Tæl antallet af hvide pixels i billedet, og du kan kende forskel på 0 og 1. Men hvad nu, hvis vi vil kende forskel på 0 og 3. Går det mon lige så nemt? Et eksempel på et håndskrevet 0 og 3-tal er vist i @fig-pixel03.

![Et billede af et håndskrevet 0 og 3-tal med en opløsning på $28 \times 28$ pixels.](mnist_filer/pixel03.png){#fig-pixel03 width=80% fig-align="center"}


Lad os prøve igen med de to features: gennemsnitlig pixelværdi og antal hvide pixels.

::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 8: Download af nyt datasæt

Brug igen [app'en](https://apps01.math.aau.dk/ai/cifre/){target="_blank"}, som viser MNIST datasættet.

+ Start med at bladre lidt rundt blandt 3-tallerne, så du får en fornemmelse for, hvordan de er skrevet.

+ Download et datasæt bestående af 0 og 3-taller i en pixelopløsning på $7 \times 7$ pixels. 

:::

::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 9: Punktplot

+ Lav et punktplot af de to features (gennemsnitlig pixelværdi og antal hvide pixels), som du gjorde det i opgave 5. Farv alle de punkter, som svarer til billeder af 0 røde, og farv alle de punkter, som svarer til billeder af 3-taller grønne.

+ Kan du på nogen måde indlægge en linje i dette plot, som på fornuftig vis kan bruges til at adskille de røde punkter fra de grønne?

:::

Det er ret tydeligt, at den gennemsnitlige pixelværdi og antallet af hvide pixels i billedet på ingen måde kan bruges til at kende forskel på 0 og 3. Det skyldes, at man åbenbart bruger cirka lige meget \"blyantsfarve\" på at skrive 0, som man gør på at skrive 3. Det viser med al tydelighed, at de features, man vælger, er fuldstændig afhængig af det klassifikationsproblem, som man står med. To features kan være formidable til ét klassifikationsproblem (at kende forskel på 0 og 1), mens de er elendige til at andet klassifikationsproblem (at kende forskel på 0 og 3). Det betyder, at vi må på jagt efter nye features!

På @fig-pixel03_7x7 ses et billede af et håndskrevet 0 og 3-tal i en opløsning på $7 \times 7$ pixels, og vi skal prøve at komme med med nogle karakteristika ved de to billeder, som kan bruges til at adskille dem. 

![Et billede af et håndskrevet 0 og 3-tal med en opløsning på $7 \times 7$ pixels.](mnist_filer/pixel03_7x7.png){#fig-pixel03_7x7 width=80% fig-align="center"}

På @fig-pixel03_7x7_vandret har vi lagt et vandret vindue ind over en række af pixels på de to billeder. Vi vil her tælle, hvor mange gange pixelværdierne \"topper\". En sådan \"top\" kalder vi for et lokalt maksimum. På billedet af 0, kan vi se, at der er to lokale maksima, mens der på billedet af 3-tallet kun er ét lokalt maksimum. Hvis vi ser på de vandrette pixelværdier på et billede af et 0, vil Vi umiddelbart tænke, at der ofte vil være to lokale maksima. Ser vi derimod på vandrette pixelværdier på et billede af et 3-tal, vil der nok nogle gange være to lokale maksima, mens der andre gange kun vil være et..

![Et billede af et håndskrevet 0 og 2-tal med et vandret vindue indlagt.](mnist_filer/pixel03_7x7_vandret.png){#fig-pixel03_7x7_vandret width=80% fig-align="center"}

Lægger vi derimod et lodret vindue ind, vil vi igen tænke, at der typisk vil være to lokale maksima på et billede af et 0, men der vil formentlig være to eller tre lokale maksima på et billede af et 3-tal. Dette er illustreret i @fig-pixel03_7x7_lodret.

![Et billede af et håndskrevet 0 og 2-tal med et lodret vindue indlagt.](mnist_filer/pixel03_7x7_lodret.png){#fig-pixel03_7x7_lodret width=80% fig-align="center"}

::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 10: Vandrette og lodrette lokale maksima

![](mnist_filer/pixel03_7x7.png){width=80% fig-align="center"}

Med udgangspunkt i ovenstående billede af et 0 og et 3-tal skal du:

+ Bestem antallet af lokale maksima i alle vandrette rækker.

+ Udregn det gennemsnitlige antal vandrette lokale maksima.

+ Bestem det største antal lokale maksima i alle vandrette rækker.

+ Bestem antallet af lokale maksima i alle lodrette rækker.

+ Udregn det gennemsnitlige antal lodrette lokale maksima.

+ Bestem det største antal lokale maksima i alle lodrette rækker.
:::

::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 11: Vandrette og lodrette lokale maksima

Brug igen [app'en](https://apps01.math.aau.dk/ai/cifre/){target="_blank"}. Sæt under \"Features\" flueben ved \"Vis lodrette lokale maksima\" og \"Vis vandrette lokale maksima\".

Billederne fra opgave 10 har id 0 og 300.

+ Kontroller ved hjælp af app'en dit resultat fra opgave 10.

:::

::: {.callout-note collapse="false" appearance="minimal"}

### Opgave 12: Download af data

I det følgende vælger vi, at arbejde med en opløsning på $14 \times 14$ pixels, så vi får et lidt mere finkornet billede at arbejde videre med.

Under fanen \"Download data\" vælger du derfor:

+ En pixel-opløsning på 14.
+ Under \"Tal\" sætter du flueben ved 0 og 3.
+ I det følgende sætter du flueben ved alle seks features.
+ Tryk på \"Download data\".

:::

Husk at vælge stil (boller og krydser)