<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Her ser vi på et simpelt kunstigt neuralt nerværk med to skjulte lag, men hvor hvert skjult lag kun består af én neuron. I dette simple tilfælde forklarer vi, hvad <strong>feedforward</strong> og <strong>backpropagation</strong> handler om, ligesom vi også kommer ind på træningsdata og tabsfunktion.">

<title>Simple kunstige neurale netværk – AI MAT - matematikken bag magien</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo/SVG/Bomaerke_05_AIMAT_2024.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-listing/list.min.js"></script>
<script src="../../site_libs/quarto-listing/quarto-listing.js"></script>
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-a92bfcb80a15d90ef98da459e5c23ce9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>

  window.document.addEventListener("DOMContentLoaded", function (_event) {
    const listingTargetEl = window.document.querySelector('#listing-main-listing-content .list');
    if (!listingTargetEl) {
      // No listing discovered, do not attach.
      return; 
    }

    const options = {
      valueNames: ['listing-title','listing-description-meta',{ data: ['index'] },{ data: ['categories'] },{ data: ['listing-date-sort'] },{ data: ['listing-title-sort'] }],
      
      searchColumns: ["listing-title","listing-author"],
    };

    window['quarto-listings'] = window['quarto-listings'] || {};
    window['quarto-listings']['listing-main-listing-content'] = new List('listing-main-listing-content', options);

    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  });

  window.addEventListener('hashchange',() => {
    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  })
  </script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Y219BCPS45"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
 
  gtag('consent', 'default', {
    'ad_storage': 'denied',
    'analytics_storage': 'denied'
  });
gtag('config', 'G-Y219BCPS45', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo/PNG/Logo_multi_AIMAT_RGB_2024.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../undervisningsforlob/index.html"> 
<span class="menu-text">Undervisningsforløb</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../materialer/index.html"> 
<span class="menu-text">Materialer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sro/index.html"> 
<span class="menu-text">SRO</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../srp/index.html"> 
<span class="menu-text">SRP</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../apps/index.html"> 
<span class="menu-text">Apps</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../referencer/index.html"> 
<span class="menu-text">Referencer</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Om os</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.youtube.com/@ai-mat"> 
<span class="menu-text"><img src="../../logo/YouTube/youtube-color-darkblue-icon.svg" style="height:2em"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Indhold</h2>
   
  <ul>
  <li><a href="#kan-vi-forudsige-vejret" id="toc-kan-vi-forudsige-vejret" class="nav-link active" data-scroll-target="#kan-vi-forudsige-vejret">Kan vi forudsige vejret?</a></li>
  <li><a href="#feedforward" id="toc-feedforward" class="nav-link" data-scroll-target="#feedforward">Feedforward</a></li>
  <li><a href="#træningsdata-og-tabsfunktion" id="toc-træningsdata-og-tabsfunktion" class="nav-link" data-scroll-target="#træningsdata-og-tabsfunktion">Træningsdata og tabsfunktion</a></li>
  <li><a href="#kædereglen" id="toc-kædereglen" class="nav-link" data-scroll-target="#kædereglen">Kædereglen</a></li>
  <li><a href="#backpropagation" id="toc-backpropagation" class="nav-link" data-scroll-target="#backpropagation">Backpropagation</a>
  <ul class="collapse">
  <li><a href="#opdatering-af-w-vægtene" id="toc-opdatering-af-w-vægtene" class="nav-link" data-scroll-target="#opdatering-af-w-vægtene">Opdatering af <span class="math inline">\(w\)</span>-vægtene</a></li>
  <li><a href="#opdatering-af-v-vægtene" id="toc-opdatering-af-v-vægtene" class="nav-link" data-scroll-target="#opdatering-af-v-vægtene">Opdatering af <span class="math inline">\(v\)</span>-vægtene</a></li>
  <li><a href="#opdatering-af-r-vægtene" id="toc-opdatering-af-r-vægtene" class="nav-link" data-scroll-target="#opdatering-af-r-vægtene">Opdatering af <span class="math inline">\(r\)</span>-vægtene</a></li>
  <li><a href="#opsummering-af-backpropagation" id="toc-opsummering-af-backpropagation" class="nav-link" data-scroll-target="#opsummering-af-backpropagation">Opsummering af backpropagation</a></li>
  </ul></li>
  <li><a href="#og-hvor-blev-den-vejrudsigt-så-af" id="toc-og-hvor-blev-den-vejrudsigt-så-af" class="nav-link" data-scroll-target="#og-hvor-blev-den-vejrudsigt-så-af">Og hvor blev den vejrudsigt så af?</a></li>
  <li><a href="#relaterede-forløb" id="toc-relaterede-forløb" class="nav-link" data-scroll-target="#relaterede-forløb">Relaterede forløb</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simple kunstige neurale netværk</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Et generelt kunstigt neuralt netværk består af en masse neuroner, som er sat sammen i en række lag. Det kunne for eksempel se ud som i <a href="#fig-long_NN" class="quarto-xref">figur&nbsp;1</a>, hvor de grønne neuroner i midten repræsenterer de såkaldte skjulte lag.</p>
<div id="fig-long_NN" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-long_NN-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/generelt_netvaerk.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-long_NN-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;1: Generelt kunstigt neuralt netværk med flere skjulte lag.
</figcaption>
</figure>
</div>
<p>I denne note vil vi se på et mere simpelt tilfælde, som det er vist i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a>. Her er der kun to skjulte lag, og hver af disse lag består kun af én neuron. Sådanne netværk, hvor de skjulte lag netop kun består af én neuron, vil vi her kalde for <strong>simple kunstige neurale netværk</strong>. På den måde befinder disse netværk sig begrebsmæssigt "in between" <a href="../../materialer/perceptron/perceptron.html">perceptroner</a> og <a href="../../materialer/kunstige_neuroner/kunstige_neuroner.html">kunstige neuroner</a> på den ene side og <a href="../../materialer/neurale_net/neurale_net.html">generelle kunstige neurale netværk</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> på den anden. De simple kunstige neurale netværk har den fordel, at de giver en fin forståelse af, hvad neurale netværk er – herunder hvad <strong>feedforward</strong> og <strong>backpropagation</strong> går ud på – men samtidig uden, at det bliver alt for matematisk svært.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Som vi ofte bare vil referere til som <em>neurale netværk</em>.</p></div></div><p>Så lad os komme i gang! Udgangspunktet er et eksempel om at lave en simpel vejrudsigt.</p>
<section id="kan-vi-forudsige-vejret" class="level2">
<h2 class="anchored" data-anchor-id="kan-vi-forudsige-vejret">Kan vi forudsige vejret?</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/vejrudsigt.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:75.0%"></p>
</figure>
</div>
<p>Forestil dig, at du gerne vil kunne forudsige, om det bliver regnvejr i morgen. Det er selvfølgelig ikke nogen helt simpel opgave, men man kunne forestille sig, at der vil være en række variable, som kan hjælpe med at lave den forudsigelse. Det kunne for eksempel være:</p>
<p><span id="eq-inputvar"><span class="math display">\[
\begin{aligned}
&amp;x_1: \textrm{Er det regnvejr i dag? Hvis 'ja' er } x_1=1 \textrm{ og } 0 \textrm{ ellers.} \\
&amp;x_2: \textrm{Luftfugtigheden i dag.} \\
&amp;x_3: \textrm{Temperaturen i dag.} \\
&amp;x_4: \textrm{Lufttrykket i dag.} \\
\end{aligned}
\tag{1}\]</span></span></p>
<p>Og der vil sikkert være en masse andre variable, som også kunne give mening. Disse variable <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> kaldes for <strong>inputvariable</strong>.</p>
<p>Vi vil nu se på, hvordan man ved hjælp af sådanne inputvariable kan prædiktere, om det bliver regnvejr i morgen.</p>
</section>
<section id="feedforward" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="feedforward">Feedforward</h2>
<p>Vi starter med at se på det mere generelle tilfælde, hvor vi har <span class="math inline">\(n\)</span> inputvariable:</p>
<p><span class="math display">\[
x_1, x_2, \dots, x_n.
\]</span> Disse inputvariable sender vi nu ind i et forholdsvis simpelt neuralt netværk, som vist i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a>.</p>
<div id="fig-long_simple_NN" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-long_simple_NN-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/long_simple_NN.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-long_simple_NN-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;2: Grafisk illustration af et neuralt netværk med <span class="math inline">\(n\)</span> inputvariable og to skjulte lag, som hver består af én neuron.
</figcaption>
</figure>
</div>
<p>De grønne og blå cirkler i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a> kaldes for <strong>neuroner</strong>. Idéen er, at vi på baggrund af inputværdierne (her vist som de lilla cirkler til venstre) i sidste ende vil beregne en outputværdi <span class="math inline">\(o\)</span> (som er illustreret ved den blå cirkel længst til højre). Outputværdien skal i dette eksempel være et tal mellem <span class="math inline">\(0\)</span> og <span class="math inline">\(1\)</span>, som skal kunne fortolkes som sandsynligheden for, at det bliver regnvejr i morgen baseret på inputværdierne <span class="math inline">\(x_1, x_2, \dots, x_n\)</span>. Herefter kunne man forestille sig følgende vejrudsigt:</p>
<p><span class="math display">\[
\textrm{Det bliver regnvejr i morgen: }
\begin{cases}
\textrm{Ja} &amp; \textrm{hvis } o \geq 0.5\\
\textrm{Nej} &amp; \textrm{hvis } o &lt; 0.5\\
\end{cases}
\]</span> Lad os derfor se på, hvordan <span class="math inline">\(o\)</span> kan beregnes. Det sker ved hjælp af en række vægte, som er repræsenteret ved pilene i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a>. Inputværdierne sendes frem til den første neuron (vist som en lysegrøn cirkel i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a>). Her beregnes den vægtede<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> sum:</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;Strengt taget er der ikke tale om en <em>vægtet</em> sum på grund af konstantleddet <span class="math inline">\(r_0\)</span>. Men hvis man tilføjer en inputværdi <span class="math inline">\(x_0\)</span>, som altid er <span class="math inline">\(1\)</span>, så kan udtrykket skrives <span class="math inline">\(r_0 \cdot x_0 + r_1 \cdot x_1 + r_2 \cdot x_2 + \cdots + r_n \cdot x_n.\)</span> I det tilfælde kan man tale om en vægtet sum af inputværdierne <span class="math inline">\(x_0, x_1, \dots, x_n\)</span>.</p></div></div><p><span class="math display">\[
r_0 + r_1 \cdot x_1 + r_2 \cdot x_2 + \cdots + r_n \cdot x_n.
\]</span></p>
<p>Bemærk her, at der er <span class="math inline">\(n+1\)</span> vægte, da der er inkluderet et konstantled <span class="math inline">\(r_0\)</span>.</p>
<p>Herefter benyttes en såkaldt <strong>aktiveringsfunktion</strong> på den vægtede sum. En ofte anvendt aktiveringsfunktion er sigmoid-funktionen <span class="math inline">\(\sigma\)</span>:</p>
<p><span id="eq-sigmoid"><span class="math display">\[
\sigma (x) = \frac{1}{1+\mathrm{e}^{-x}}.
\tag{2}\]</span></span></p>
<p>Det vil sige, at vi beregner</p>
<p><span class="math display">\[
\begin{aligned}
y &amp;= h(x_1, x_2, \dots, x_n) \\
&amp;=\sigma (r_0 + r_1 \cdot x_1 + r_2 \cdot x_2 + \cdots + r_n \cdot x_n) \\
&amp;= \frac{1}{1+\mathrm{e}^{-(r_0 + r_1 \cdot x_1 + r_2 \cdot x_2 + \cdots + r_n \cdot x_n)}}.
\end{aligned}
\]</span></p>
<p>Grafen for sigmoid-funktionen ses i <a href="#fig-sigmoid" class="quarto-xref">figur&nbsp;3</a>.</p>
<div id="fig-sigmoid" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/sigmoid.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;3: Grafen for sigmoid-funktionen.
</figcaption>
</figure>
</div>
<p>Her anskueliggøres det, at sigmoid-funktionen tager et vilkårligt reelt tal som input og giver et tal i intervallet <span class="math inline">\(]0,1[\)</span> som output. Det kan skrives sådan her:</p>
<p><span class="math display">\[
\sigma : \mathbb{R} \rightarrow ]0,1[.
\]</span></p>
<p>Det næste, der sker, er, at den første (lysegrønne) neuron i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a> sender værdien <span class="math inline">\(y\)</span> videre i netværket, hvor <span class="math inline">\(0&lt;y&lt;1\)</span>. Ved den næste neuron i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a> (repræsenteret ved den mørkegrønne cirkel), beregnes først <span class="math inline">\(v_0 + v_1 \cdot y\)</span> og herefter anvendes igen aktiveringsfunktionen:</p>
<p><span class="math display">\[
z = g(y) = \sigma (v_0 + v_1 \cdot y).
\]</span></p>
<p>Denne værdi sendes nu frem til den sidste neuron i outputlaget og outputværdien <span class="math inline">\(o\)</span> beregnes på tilsvarende måde</p>
<p><span class="math display">\[
o = f(z) = \sigma(w_0 + w_1 \cdot z).
\]</span></p>
<p>Hele denne proces med at udregne outputværdien <span class="math inline">\(o\)</span> på baggrund af inputværdierne <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> kaldes for <strong>feedforward</strong> og er opsummeret herunder:</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Feedforward-udtryk
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>På baggrund af inputværdierne <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> beregnes outputværdien <span class="math inline">\(o\)</span> på følgende måde.</p>
<p>Først beregnes:</p>
<p><span id="eq-y"><span class="math display">\[
y = h(x_1, x_2, \dots, x_n) = \sigma (r_0 + r_1 \cdot x_1 + r_2 \cdot x_2 + \cdots + r_n \cdot x_n)
\tag{3}\]</span></span></p>
<p>Dernæst beregnes:</p>
<p><span id="eq-z"><span class="math display">\[
z = g(y)=\sigma (v_0 + v_1 \cdot y)
\tag{4}\]</span></span></p>
<p>Og til sidst kan outputværdien <span class="math inline">\(o\)</span> beregnes:</p>
<p><span id="eq-o"><span class="math display">\[
o = f(z)=\sigma(w_0 + w_1 \cdot z)
\tag{5}\]</span></span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/long_simple_NN.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></p>
</figure>
</div>
</div>
</div>
</div>
<p>Bemærk, at outputværdien <span class="math inline">\(o\)</span> beregnes ved hjælp af sigmoid-funktionen, og derfor er et tal mellem <span class="math inline">\(0\)</span> og <span class="math inline">\(1\)</span>, som tidligere ønsket – altså kan <span class="math inline">\(o\)</span> fortolkes som en sandsynlighed.</p>
<p>Med udgangspunkt i feedforward-udtrykkene, kan vi også skrive outputværdien <span class="math inline">\(o\)</span> direkte som en funktion af inputværdierne <span class="math inline">\(x_1, x_2, \dots, x_n\)</span>. Vi starter med at indsætte udtrykket for <span class="math inline">\(z\)</span> i (<a href="#eq-z" class="quarto-xref">4</a>) i udtrykket for <span class="math inline">\(o\)</span> i (<a href="#eq-o" class="quarto-xref">5</a>):</p>
<p><span class="math display">\[
\begin{aligned}
o &amp;= f(z)=f(g(y)) \\
&amp;=\sigma(w_0 + w_1 \cdot (\sigma (v_0 + v_1 \cdot y)))
\end{aligned}
\]</span></p>
<p>Herefter erstatter vi <span class="math inline">\(y\)</span> med udtrykket i (<a href="#eq-y" class="quarto-xref">3</a>):</p>
<p><span class="math display">\[
\begin{aligned}
o &amp;= f(z)=f(g(y))=f(g(h(x_1, x_2, \dots, x_n))) \\&amp;= \sigma(w_0 + w_1 \cdot (\sigma (v_0 + v_1 \cdot (\sigma (r_0 + r_1 \cdot x_1 + r_2 \cdot x_2 + \cdots + r_n \cdot x_n) ))))
\end{aligned}
\]</span></p>
<p>Her bliver det meget tydeligt, at</p>
<ol type="1">
<li><p>Outputværdien afhænger af inputværdierne <span class="math inline">\(x_1, x_2, \dots, x_n\)</span>:</p>
<p><span class="math display">\[
o = \sigma(w_0 + w_1 \cdot (\sigma (v_0 + v_1 \cdot (\sigma (r_0 + r_1 \cdot {\color{#F288B9} x_1} + r_2 \cdot      {\color{#F288B9} x_2} + \cdots + r_n \cdot {\color{#F288B9} x_n}) ))))
\]</span></p>
<p>Det er den måde, vi forstår feedforward-udtrykkene på: Vi beregner outputværdien <span class="math inline">\(o\)</span> ud fra inputværdierne <span class="math inline">\(x_1, x_2, \dots, x_n\)</span>. Vi kan altså her tænke på outputværdien som <strong>en funktion af inputværdierne <span class="math inline">\(x_1, x_2, \dots, x_n\)</span></strong>.</p></li>
<li><p>Outputværdien afhænger <em>også</em> af alle vægtene <span class="math inline">\(w_0, w_1, v_0, v_1, r_0, r_1, \dots, r_n\)</span>: <span class="math display">\[
o =\sigma({\color{#8086F2} w_0} + {\color{#8086F2} w_1} \cdot (\sigma ({\color{#8086F2} v_0} + {\color{#8086F2} v_1} \cdot (\sigma ({\color{#8086F2} r_0} + {\color{#8086F2} r_1} \cdot x_1 + {\color{#8086F2} r_2} \cdot x_2 + \cdots + {\color{#8086F2} r_n} \cdot x_n) ))))
\]</span> Her tænker vi på <span class="math inline">\(o\)</span> som <strong>en funktion af vægtene <span class="math inline">\(w_0, w_1, v_0, v_1, r_0, r_1, \dots, r_n\)</span></strong>. Det er denne tankegang, vi skal bruge, når vi skal i gang med at træne netværket. Her er inputværdierne nemlig givet, mens vi ønsker at justere på vægtene, så netværk bliver så godt som muligt til at forudsige vejret.</p></li>
</ol>
<p>og</p>
<ol start="3" type="1">
<li><p>Outputværdien <span class="math inline">\(o\)</span> kan udtrykkes ved hjælp af flere sammensatte funktioner (her markeret med gult).</p>
<p><span class="math display">\[
o ={\color{#F2B33D} \sigma}({w_0} + {w_1} \cdot ({\color{#F2B33D} \sigma} ({v_0} + {v_1} \cdot ({\color{#F2B33D} \sigma} ({r_0} + {r_1} \cdot x_1 + {r_2} \cdot x_2 + \cdots + {r_n} \cdot x_n) ))))
\]</span></p>
<p>Det er årsagen til, at vi senere får brug for kædereglen, når vi skal i gang med at differentiere ovenstående med hensyn til vægtene.</p></li>
</ol>
<p>Bortset fra det er feedforward-udtrykkene ovenfor nok nemmere at overskue!</p>
<p>Fint nok – nu har vi altså en model, som kan bruges til at forudsige vejret. Men måske er du skeptisk. Det bør du i hvert tilfælde være! For hvem siger, at outputværdien <span class="math inline">\(o\)</span> siger noget som helst om sandsynligheden for, at det bliver regnvejr i morgen? Det korte svar er: Det gør den heller ikke nødvendigvis! I hvert tilfælde ikke sådan uden videre. Det kræver nemlig, at alle vægtene er "indstillet" sådan, at den beregnede outputværdi rent faktisk kan fortolkes som en sandsynlighed for, at det bliver regnvejr i morgen. For at lave denne "indstilling" skal vi bruge to ting: 1) træningsdata og 2) en tabsfunktion. Det kommer her.</p>
</section>
<section id="træningsdata-og-tabsfunktion" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="træningsdata-og-tabsfunktion">Træningsdata og tabsfunktion</h2>
<p>Nu tænker vi os, at du registrerer de fire størrelser i (<a href="#eq-inputvar" class="quarto-xref">1</a>) på en række forskellige dage, ligesom du også den efterfølgende dag registrerer, om det regner eller ej. Denne sidste registrering kunne for eksempel ske på denne måde:</p>
<p><span class="math display">\[
t=
\begin{cases}
1 &amp; \textrm{hvis det regner den efterfølgende dag} \\
0 &amp; \textrm{hvis det ikke regner den efterfølgende dag} \\
\end{cases}
\]</span> Variablen <span class="math inline">\(t\)</span> kaldes for en <strong>targetvariabel</strong>. Det er netop denne værdi, vi gerne vil kunne forudsige. Man kan derfor tænke på variablen <span class="math inline">\(t\)</span>, som en slags facitliste. Man siger også, vi gerne vil <strong>prædiktere</strong> <span class="math inline">\(t\)</span>.</p>
<p>Hvis vi for eksempel laver denne registrering på 10 forskellige dage kan vi skrive det op på denne måde:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\text{Dag 1:} \quad (x_1^{(1)}, x_2^{(1)}, x_3^{(1)}, x_4^{(1)}, t^{(1)}) \\
&amp;\text{Dag 2:} \quad (x_1^{(2)}, x_2^{(2)}, x_3^{(2)}, x_4^{(2)}, t^{(2)}) \\
&amp;  \quad  \vdots \\
&amp;\text{Dag 10:} \quad (x_1^{(10)}, x_2^{(10)}, x_3^{(10)}, x_4^{(10)}, t^{(10)}) \\
\end{aligned}
\]</span></p>
<p>Det hævede tal i parentes angiver altså nummeret på dagen. For eksempel angiver <span class="math inline">\(x_3^{(2)}\)</span> temperaturen på dag 2, mens <span class="math inline">\(t^{(2)}\)</span> er 1, hvis det regner dagen efter dag 2 og 0 ellers. Bemærk, at dagene ikke behøver at komme efter hinanden. Det kan tværtimod være en fordel, hvis dagene er spredt ud, så der ikke kommer afhængigheder mellem værdierne.</p>
<p>Ovenstående kaldes for <strong>træningsdata</strong>. Helt generelt med <span class="math inline">\(n\)</span> inputvariable og <span class="math inline">\(M\)</span> observationer i træningsdata vil vi opskrive træningsdatasættet sådan her:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\text{Træningseksempel 1:} \quad (x_1^{(1)}, x_2^{(1)}, \dots, x_n^{(1)}, t^{(1)}) \\
&amp;  \quad \quad \quad \quad \vdots \\
&amp;\text{Træningseksempel m:} \quad (x_1^{(m)}, x_2^{(m)}, \dots, x_n^{(m)}, t^{(m)}) \\
&amp;  \quad \quad \quad \quad \vdots \\
&amp;\text{Træningseksempel M:} \quad (x_1^{(M)}, x_2^{(M)}, \dots, x_n^{(M)}, t^{(M)}) \\
\end{aligned}
\]</span></p>
<p>Vi kan nu tage hvert træningsdataeksempel og sende det ind i netværket i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a>. Det gør vi ved hjælp af feedforward-udtrykkene i (<a href="#eq-y" class="quarto-xref">3</a>), (<a href="#eq-z" class="quarto-xref">4</a>) og (<a href="#eq-o" class="quarto-xref">5</a>). Vi får derfor for hvert træningseksempel beregnet en outputværdi <span class="math inline">\(o\)</span>. Outputværdien for det <span class="math inline">\(m\)</span>’te træningseksempel vil vi kalde for <span class="math inline">\(o^{(m)}\)</span>.</p>
<p>Hvis netværket er godt – det vil sige, hvis vi har fundet nogle "gode" værdier af vægtene, så vil outputværdien <span class="math inline">\(o\)</span> kunne fortolkes som sandsynligheden for, om det bliver regnvejr i morgen.</p>
<p>Det betyder, at et godt netværk har denne egenskab:</p>
<ul>
<li>Hvis <span class="math inline">\(t=1\)</span>, så er <span class="math inline">\(o \approx 1\)</span>.</li>
<li>Hvis <span class="math inline">\(t=0\)</span>, så er <span class="math inline">\(o \approx 0\)</span>.</li>
</ul>
<p>I begge tilfælde betyder det, at <span class="math display">\[
t-o \approx 0.
\]</span></p>
<p>Det er præcis denne differens, som vi vil bruge som et mål for, hvor godt netværket er.</p>
<p>Nu kan denne differens både være positiv og negativ. Derfor vil vi se på den kvadrerede differens:</p>
<p><span class="math display">\[
(t-o)^2.
\]</span></p>
<p>Hvis netværket er godt, vil denne kvadrerede differens stadig være tæt på <span class="math inline">\(0\)</span>. Samtidig vil der jo også være en differens for hvert træningsdataeksempel:</p>
<p><span class="math display">\[
(t^{(1)}-o^{(1)})^2, (t^{(2)}-o^{(2)})^2, \dots, (t^{(M)}-o^{(M)})^2.
\]</span></p>
<p>Det er summen af alle disse differenser (ganget<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> med <span class="math inline">\(1/2\)</span>), som vi vil bruge som mål for, hvor godt netværket er:</p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;At vi ganger med <span class="math inline">\(1/2\)</span> er ikke så vigtigt – du ser senere, hvorfor det er smart.</p></div></div><p><span class="math display">\[
E = \frac{1}{2} \sum_{m=1}^M (t^{(m)}-o^{(m)})^2
\]</span></p>
<p>Denne funktion er den, som vi kalder for en <a href="../../materialer/tabsfunktioner/tabsfunktioner.html"><strong>tabsfunktion</strong></a> (eller på engelsk <em>error function</em> – deraf <span class="math inline">\(E\)</span>’et). Som vi har argumenteret for ovenfor, så er vi netop på jagt efter de værdier af vægtene, som minimerer tabsfunktionen.</p>
<p>Tabsfunktionen ovenfor kan også omskrives en smule:</p>
<p><span id="eq-E"><span class="math display">\[
\begin{aligned}
E &amp;= \frac{1}{2} \sum_{m=1}^M (t^{(m)}-o^{(m)})^2 \\
&amp;= \sum_{m=1}^M \frac{1}{2} (t^{(m)}-o^{(m)})^2 \\
&amp;= \sum_{m=1}^M E^{(m)},
\end{aligned}
\tag{6}\]</span></span></p>
<p>hvor</p>
<p><span id="eq-E_m"><span class="math display">\[
E^{(m)} = \frac{1}{2} (t^{(m)}-o^{(m)})^2
\tag{7}\]</span></span></p>
<p>er det bidrag til tabsfunktionen, som stammer fra det <span class="math inline">\(m\)</span>’te træningseksempel.</p>
<p>For at finde værdier af vægtene som minimerer tabsfunktionen bruges en metode, som kaldes for <strong>backpropagation</strong>. Det forklarer vi lige om lidt, men vi kan allerede nu afsløre, at vi får brug for at kunne differentiere tabsfunktionen. Vi har tidligere set, at alle outputværdierne <span class="math inline">\(o^{(m)}\)</span> er en sammensat funktion. Derfor bliver tabsfunktionen også en sammensat funktion. Det betyder, at vi får brug for at kunne differentiere sammensatte funktioner, og det siger kædereglen noget om. Men først skal vi se, hvordan kædereglen kan opskrives på en smart måde, hvilket vi skal bruge i forbindelse med backpropagation.</p>
</section>
<section id="kædereglen" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="kædereglen">Kædereglen</h2>
<p>Du kender godt de sammensatte funktioner. Det kunne for eksempel være en funktion<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> <span class="math inline">\(k\)</span>:</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;Bemærk her, at vi kalder en funktion for <span class="math inline">\(k\)</span>, men det er altså ikke at veksle med en konstant, som vi også ofte kalder for <span class="math inline">\(k\)</span>!</p></div></div><p><span class="math display">\[
k(x)= f(g(x))
\]</span></p>
<p>Funkionen <span class="math inline">\(k\)</span> afhænger af <span class="math inline">\(x\)</span>, men det sker via den indre funktion <span class="math inline">\(g\)</span> og den ydre funktion <span class="math inline">\(f\)</span>. Altså <span class="math inline">\(k\)</span> er sammensat af en indre og en ydre funktion:</p>
<ul>
<li>Indre funktion: <span class="math inline">\(u=g(x)\)</span></li>
<li>Ydre funktion: <span class="math inline">\(f(u)\)</span></li>
</ul>
<p>Idéen er illustreret i <a href="#fig-sammensatfunktion" class="quarto-xref">figur&nbsp;4</a>.</p>
<div id="fig-sammensatfunktion" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-sammensatfunktion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/sammensatfunktion.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-sammensatfunktion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;4: Illustration af funktionen <span class="math inline">\(k\)</span> som er sammensat af den indre funktion <span class="math inline">\(g\)</span> og den ydre funktion <span class="math inline">\(f\)</span>.
</figcaption>
</figure>
</div>
<p>For at beregne <span class="math inline">\(k(x)\)</span> "sender" vi først <span class="math inline">\(x\)</span> ind i "funktionsmaskinen" for <span class="math inline">\(g\)</span>. Her bliver <span class="math inline">\(g(x)\)</span> beregnet. Denne værdi "sendes" så ind i "funktionsmaskinen" for <span class="math inline">\(f\)</span> og dermed bliver <span class="math inline">\(f(g(x))\)</span> beregnet, som netop er <span class="math inline">\(k(x)\)</span>.</p>
<p>Hvis vi skal differentiere funktionen <span class="math inline">\(k\)</span>, så skal vi bruge reglen for at differentiere sammensatte funktioner:</p>
<p><span id="eq-k_diff"><span class="math display">\[
k'(x)=f'(g(x)) \cdot g'(x)
\tag{8}\]</span></span></p>
<p>Det er altså den ydre funktion differentieret <em>taget på den indre</em><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> gange den indre funktion differentieret.</p>
<div class="no-row-height column-margin column-container"><div id="fn5"><p><sup>5</sup>&nbsp;Det betyder, at der står <span class="math inline">\(f'(g(x))\)</span> og for eksempel ikke <span class="math inline">\(f'(x)\)</span>.</p></div></div><p>Hvis vi erstatter <span class="math inline">\(g(x)\)</span> med <span class="math inline">\(u\)</span> kan det skrives:</p>
<p><span class="math display">\[
k'(x)=f'(u) \cdot g'(x)
\]</span></p>
<p>Du har måske også lært, at man i stedet for at bruge mærker til at angive, at man har differentieret, kan skrive sådan her (kært barn har som bekendt mange navne):</p>
<p><span class="math display">\[
\frac{dk}{dx} = \frac{df}{du} \cdot \frac{du}{dx}
\]</span></p>
<p>Denne måde at skrive reglen for at differentiere sammensatte funktioner på kaldes for <strong>kædereglen</strong><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. Navnet kædereglen kommer af, at de diffenrentialkvotienter, som indgår på højre side bliver "kædet" sammen. Det er nemmest at illustrere med farver:</p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;Bemærk, at denne måde at skrive en differentialkvotient på (<span class="math inline">\(\frac{dk}{dx}\)</span>) ikke er en egentlig brøk, selvom det ligner. Det svarer derimod til grænseværdien af en brøk (nemlig grænseværdien af en differenskvotient).</p></div></div><p><span class="math display">\[
\frac{dk}{dx} = \frac{df}{\color{#8086F2} du} \color{black}\cdot \frac{\color{#8086F2} du \color{black}}{dx}
\]</span></p>
<p>Bemærk, at denne notation jo er noget kortere end udtrykket i (<a href="#eq-k_diff" class="quarto-xref">8</a>), men vi har også "fejet noget ind under gulvtæppet". Det er nemlig ikke tydeligt, hvad de afledede funktioner skal evalueres i. I (<a href="#eq-k_diff" class="quarto-xref">8</a>) ses det tydeligt, at <span class="math inline">\(f'\)</span> skal evalueres i <span class="math inline">\(g(x)\)</span>, mens <span class="math inline">\(g'\)</span> skal evalueres i <span class="math inline">\(x\)</span>. Denne information er underforstået, når vi bruger "kæderegelsnotationen" ovenfor. Hvis man vil, kan man pakke kædereglen lidt mere ud, så det bliver tydeligere:</p>
<p><span class="math display">\[
\frac{dk}{dx} (x) = \frac{df}{du} (u) \cdot \frac{du}{dx} (x),
\]</span></p>
<p>hvor</p>
<p><span class="math display">\[
u = g(x).
\]</span> Selvom denne måde at skrive det på er mere korrekt, vil vi alligevel for enkelthedens skyld holde fast i notationen i (<a href="#eq-k_diff" class="quarto-xref">8</a>).</p>
<p>Kædereglen bliver endnu tydeligere, hvis vi ser på en funktion, som er sammensat af ikke bare to, men tre funktioner:</p>
<p><span class="math display">\[
k(x) = f(g(h(x)))
\]</span> Denne funktion er sammensat af tre funktioner:</p>
<ul>
<li>Indre funktion: <span class="math inline">\(y=h(x)\)</span></li>
<li>Indre funktion: <span class="math inline">\(z=g(y)\)</span></li>
<li>Ydre funktion: <span class="math inline">\(f(z)\)</span></li>
</ul>
<p>For at differentiere <span class="math inline">\(k\)</span> må vi først bruge kædereglen én gang:</p>
<p><span class="math display">\[
k'(x)= f'(g(h(x))) \cdot \left ( g(h(x))\right)'
\]</span> For at differentiere den sidste faktor må vi bruge kædereglen endnu en gang:</p>
<p><span class="math display">\[
\left ( g(h(x))\right)' = g'(h(x)) \cdot h'(x)
\]</span></p>
<p>Det vil sige, at vi samlet set ender med:</p>
<p><span class="math display">\[
k'(x)= f'(g(h(x))) \cdot g'(h(x)) \cdot h'(x)
\]</span> Bruger vi notation med <span class="math inline">\(dk/dx\)</span> og husker på, at</p>
<p><span class="math display">\[
z = g(y) \qquad \textrm{og} \qquad y = h(x)
\]</span></p>
<p>kan ovenstående skrives som:</p>
<p><span class="math display">\[
\frac{dk}{dx} = \frac{df}{dz} \cdot \frac{dz}{dy} \cdot \frac{dy}{dx}
\]</span></p>
<p>Og med farver bliver det tydeligt, hvorfor der er tale om en <strong>kæde</strong>regel:</p>
<p><span class="math display">\[
\frac{dk}{dx} = \frac{df}{\color{#8086F2} dz} \cdot \frac{\color{#8086F2} dz}{\color{#F288B9} dy} \cdot \frac{\color{#F288B9} dy}{dx}
\]</span></p>
<p>Denne måde at skrive kædereglen på får vi brug for i det følgende.</p>
</section>
<section id="backpropagation" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="backpropagation">Backpropagation</h2>
<p>Husk på at vi gerne vil bestemme de værdier af vægtene, så tabsfunktionen i (<a href="#eq-E" class="quarto-xref">6</a>) bliver minimeret. Når man skal minimere <a href="../../materialer/funktioner_af_flere_variable/funktioner_af_flere_variable.html">en funktion af flere variable</a> kan man egentlig bare sætte alle de partielle afledede lig med 0. Det vil give lige så mange ligninger, som der er vægte (og alle ligninger vil være koblet til hinanden). I vores simple eksempel her vil det ikke være noget problem at løse de ligninger. Men i virkelighedens verden, hvor de kunstige neurale netværk afhænger af millioner eller milliarder af vægte, er denne fremgangsmåde beregningsmæssigt alt for tung. Det vil dels tage alt for lang tid, og det vil dels tage for meget plads på computeren.</p>
<p>Man bruger derfor en anden metode, som kaldes for <strong>backpropagation</strong>. I backpropagation bruger man for det første gradientnedstigning, så den tager vi lige først.</p>
<p>Vi forestiller os, at vi har en funktion <span class="math inline">\(f\)</span>, som afhænger af <span class="math inline">\(x_1, x_2, \dots, x_n\)</span>. Vi "stiller" os nu et tilfældigt sted på grafen for <span class="math inline">\(f\)</span> og udregner gradienten</p>
<p><span class="math display">\[
\nabla f(x_1, x_2, \dots, x_n) =
\begin{pmatrix}
\frac{\partial f}{\partial x_1} \\
\frac{\partial f}{\partial x_2} \\
\vdots \\
\frac{\partial f}{\partial x_n}
\end{pmatrix}.
\]</span></p>
<p>Så viser det sig, at gradienten peger i den retning, hvor funktionsværdien vokser mest. Derfor vil minus gradienten pege i den retning, hvor funktionsværdien aftager mest. Visuelt kan man forestille sig, at man står i et bakkelandskab, hvor man gerne vil ned i en dal. Så kan man tænke på den negative gradient, som den retning vi skal bevæge os i, hvis vi gerne vil gå allermest nedad bakke (og det er jo smart, hvis man gerne vil ende i dalen). Man udregner derfor gradienten og går et lille stykke i den negative gradients retning. Nu er det jo ikke sikkert, at man hele tiden skal gå i den samme retning, så derfor er man nødt til at udregne gradienten igen på det nye sted, man nu står og så korrigere sin retning i forhold det næste lille skridt, man tager.</p>
<p>Det er altså idéen, hvis man gerne vil bestemme minimum. Man stiller sig simpelthen et tilfældigt sted på grafen for <span class="math inline">\(f\)</span> og udregner gradienten. Så bevæger man sig et lille stykke i den negative gradients retning. I det nye punkt udregner man gradienten igen og går et lille stykke i den nye negative gradients retning. Sådan fortsætter man, indtil funktionsværdien ikke ændrer sig ret meget, og man er landet i et minimum (eventuelt kun lokalt).</p>
<p>Nu hedder vores funktion ikke <span class="math inline">\(f\)</span>, men <span class="math inline">\(E\)</span> (det var tabsfunktionen). <span class="math inline">\(E\)</span> afhænger af vægtene <span class="math inline">\(r_0, r_1, \dots, r_n, v_0, v_1, w_0\)</span> og <span class="math inline">\(w_1\)</span>. Vi vælger derfor nogle tilfældige værdier af disse vægte og udregner gradienten. Så opdaterer vi alle vægtene ved at gå et lille stykke <span class="math inline">\(\eta\)</span> i den negative gradients retning. For at beregne den nye værdi af <span class="math inline">\(w_1\)</span>, som vi her vil kalde for <span class="math inline">\(w_1^{\textrm{ny}}\)</span>, vil det for eksempel se sådan her ud:</p>
<p><span class="math display">\[
w_1^{\textrm{ny}} \leftarrow w_1 - \eta \cdot \frac{\partial E}{\partial w_1}
\]</span></p>
<p>Det lille stykke <span class="math inline">\(\eta\)</span>, som vi går i den negative gradients retning, kaldes også for en <em>learning rate</em>. Her er <span class="math inline">\(w_1\)</span> den "nuværende" værdi af vægten, og pilen til venstre betyder, at der foretages en opdatering. Den nye værdi af vægten kaldes, som sagt, for <span class="math inline">\(w_1^{\textrm{ny}}\)</span>.</p>
<p>I backpropagation opdateres vægtene ved at bruge ovenstående opdateringsregel, men det gøres på en snedig måde. Nemlig ved at opdatere vægtene tættest på outputlaget først – det vil sige <span class="math inline">\(w_0\)</span> og <span class="math inline">\(w_1\)</span>. Dernæst går man en skidt længere tilbage i netværket i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a> og opdaterer <span class="math inline">\(v_0\)</span> og <span class="math inline">\(v_1\)</span> og endelig opdaterer man til sidst vægtene tættest på inputlaget <span class="math inline">\(r_0, r_1, \dots, r_n\)</span>. Vi skal nok forklare, hvorfor det er smart, men det er altså årsagen til, at metoden kaldes for <strong>back</strong>propagation: Fordi vægtene opdateres fra outputlaget og bagud.</p>
<p>Inden opdateringen af vægtene går i gang sættes alle vægtene til en tilfældig værdi. Herefter tager vi alle <span class="math inline">\(M\)</span> træningsdata og sender ind i netværket. Det vil sige, at vi på baggrund af feedforward-udtrykkene i (<a href="#eq-y" class="quarto-xref">3</a>), (<a href="#eq-z" class="quarto-xref">4</a>) og (<a href="#eq-o" class="quarto-xref">5</a>) udregner følgende for det <span class="math inline">\(m\)</span>’te træningsdataeksempel:</p>
<p><span id="eq-y_m"><span class="math display">\[
y^{(m)} = \sigma (r_0 + r_1 \cdot x_1^{(m)} + r_2 \cdot x_2^{(m)} + \cdots + r_n \cdot x_n^{(m)})
\tag{9}\]</span></span></p>
<p><span id="eq-z_m"><span class="math display">\[
z^{(m)} = \sigma (v_0 + v_1 \cdot y^{(m)})
\tag{10}\]</span></span></p>
<p><span id="eq-o_m"><span class="math display">\[
o^{(m)} = \sigma(w_0 + w_1 \cdot z^{(m)})
\tag{11}\]</span></span></p>
<p>og det gør vi altså for alle <span class="math inline">\(M\)</span> træningsdata <span class="math inline">\(m \in \{1, 2, \dots, M\}\)</span>. Alle disse værdier af <span class="math inline">\(y^{(m)}\)</span>, <span class="math inline">\(z^{(m)}\)</span> og <span class="math inline">\(o^{(m)}\)</span> får vi nemlig brug for, når vi skal i gang med at opdatere vægtene.</p>
<p>Vi er nu klar til at opdatere vægtene <span class="math inline">\(w\)</span>-vægtene, som ligger tættest på outputlaget.</p>
<section id="opdatering-af-w-vægtene" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="opdatering-af-w-vægtene">Opdatering af <span class="math inline">\(w\)</span>-vægtene</h3>
<p>Ved at bruge gradientnedstigning bliver opdateringsligningerne for <span class="math inline">\(w\)</span>-vægtene følgende:</p>
<p><span id="eq-generel_opdatering_w"><span class="math display">\[
\begin{aligned}
w_0^{\textrm{ny}} &amp;\leftarrow w_0 - \eta \cdot \frac{\partial E}{\partial w_0} \\
w_1^{\textrm{ny}} &amp;\leftarrow w_1 - \eta \cdot \frac{\partial E}{\partial w_1}
\end{aligned}
\tag{12}\]</span></span></p>
<p>Vi skal altså differentiere tabsfunktionen</p>
<p><span class="math display">\[
\begin{aligned}
E = \sum_{m=1}^M \frac{1}{2} (t^{(m)}-o^{(m)})^2 = \sum_{m=1}^M E^{(m)},
\end{aligned}
\]</span> hvor</p>
<p><span class="math display">\[
E^{(m)} = \frac{1}{2} (t^{(m)}-o^{(m)})^2
\]</span> med hensyn til <span class="math inline">\(w_0\)</span> og <span class="math inline">\(w_1\)</span>. Lad os starte med <span class="math inline">\(w_1\)</span>. For det første skal vi huske, at man kan differentiere ledvist (det er sumreglen). Det giver:</p>
<p><span class="math display">\[
\frac{\partial E}{\partial w_1} =  \sum_{m=1}^M \frac{\partial E^{(m)}}{\partial w_1}
\]</span></p>
<p>For det andet får vi brug for kædereglen, da <span class="math inline">\(E^{(m)}\)</span> jo er en sammensat funktion. På <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a> kan man se, at tabsfunktionen afhænger af <span class="math inline">\(w_1\)</span> via outputværdien <span class="math inline">\(o^{(m)}\)</span>. Derfor giver kædereglen:</p>
<p><span id="eq-dE_dw1"><span class="math display">\[
\frac{\partial E}{\partial w_1} =  \sum_{m=1}^M \frac{\partial E^{(m)}}{\partial o^{(m)}} \cdot \frac{\partial o^{(m)}}{\partial w_1}
\tag{13}\]</span></span></p>
<p>Vi ser nu på hver faktor i denne sum for sig. For at bestemme <span class="math inline">\(\frac{\partial E^{(m)}}{\partial o^{(m)}}\)</span> skal vi bruge definitionen i (<a href="#eq-E_m" class="quarto-xref">7</a>):</p>
<p><span class="math display">\[
E^{(m)} = \frac{1}{2} (t^{(m)}-o^{(m)})^2
\]</span></p>
<p>Her bruger vi også kædereglen. Det giver</p>
<p><span id="eq-dE_do"><span class="math display">\[
\begin{aligned}
\frac{\partial E^{(m)}}{\partial o^{(m)}} &amp;= \frac{1}{2} \cdot 2 \cdot (t^{(m)}-o^{(m)}) \cdot  (-1) \\
&amp;= - (t^{(m)}-o^{(m)})
\end{aligned}
\tag{14}\]</span></span></p>
<p>Bemærk for øvrigt, at <span class="math inline">\(\frac{1}{2}\)</span> og <span class="math inline">\(2\)</span> forkorter ud. Det var derfor, at vi gangede tabsfunktionen i (<a href="#eq-E" class="quarto-xref">6</a>) med <span class="math inline">\(\frac{1}{2}\)</span>.</p>
<p>For at finde <span class="math inline">\(\frac{\partial o^{(m)}}{\partial w_1}\)</span> skal vi bruge feedforward-ligningen i (<a href="#eq-o_m" class="quarto-xref">11</a>):</p>
<p><span class="math display">\[
o^{(m)} = \sigma(w_0 + w_1 \cdot z^{(m)})
\]</span></p>
<p>Det er også en sammensat funktion, og bruger vi kædereglen på dette udtryk, får vi</p>
<p><span class="math display">\[
\frac{\partial o^{(m)}}{\partial w_1} = \sigma'(w_0 + w_1 \cdot z^{(m)}) \cdot z^{(m)},
\]</span></p>
<p>idet den indre funktion <span class="math inline">\(w_0 + w_1 \cdot z^{(m)}\)</span> differentieret med hensyn til <span class="math inline">\(w_1\)</span> bare giver <span class="math inline">\(z^{(m)}\)</span>. Af ovenstående fremgår det, at vi får brug for at differentiere sigmoid-funktionen. Det viser sig, at den afledede sigmoid-funktion kan udtrykkes simpelt ved hjælp af sigmoid-funktionen selv på denne måde<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>:</p>
<div class="no-row-height column-margin column-container"><div id="fn7"><p><sup>7</sup>&nbsp;Se eventuelt mere i <a href="../../undervisningsforlob/aktiveringsfunktioner.html#sigmoid" target="”blank”">opgave 2 her</a>.</p></div></div><div class="highlight">
<p><strong>Den afledede sigmoid-funktion</strong></p>
<p><span id="eq-afledt_sigmoid"><span class="math display">\[
\sigma'(x) = \sigma(x) \cdot (1-\sigma(x))
\tag{15}\]</span></span></p>
</div>
<p><br></p>
<p>Bruger vi denne særlige egenskab, får vi</p>
<p><span class="math display">\[
\frac{\partial o^{(m)}}{\partial w_1} = \sigma(w_0 + w_1 \cdot z^{(m)}) \cdot (1-\sigma(w_0 + w_1 \cdot z^{(m)})) \cdot z^{(m)}
\]</span></p>
<p>Og da <span class="math inline">\(o^{(m)}=\sigma(w_0 + w_1 \cdot z^{(m)})\)</span> kan dette skrives som</p>
<p><span id="eq-do_dw1"><span class="math display">\[
\frac{\partial o^{(m)}}{\partial w_1} = o^{(m)} \cdot (1-o^{(m)}) \cdot z^{(m)}
\tag{16}\]</span></span></p>
<p>Hvis vi indsætter udtrykket i (<a href="#eq-dE_do" class="quarto-xref">14</a>) og (<a href="#eq-do_dw1" class="quarto-xref">16</a>) i (<a href="#eq-dE_dw1" class="quarto-xref">13</a>), får vi</p>
<p><span class="math display">\[
\frac{\partial E}{\partial w_1}= - \sum_{m=1}^M (t^{(m)}-o^{(m)}) \cdot o^{(m)} \cdot (1-o^{(m)}) \cdot z^{(m)}
\]</span></p>
<p>Indsættes dette i (<a href="#eq-generel_opdatering_w" class="quarto-xref">12</a>) bliver opdateringsreglen for <span class="math inline">\(w_1\)</span>:</p>
<p><span class="math display">\[
w_1^{\textrm{ny}} \leftarrow w_1 + \eta \cdot \sum_{m=1}^M (t^{(m)}-o^{(m)}) \cdot o^{(m)} \cdot (1-o^{(m)}) \cdot z^{(m)}
\]</span></p>
<p>Hvis vi lader</p>
<p><span id="eq-delta_m"><span class="math display">\[
\delta_w^{(m)} = (t^{(m)}-o^{(m)} ) \cdot o^{(m)}  \cdot (1-o^{(m)})
\tag{17}\]</span></span></p>
<p>kan det skrives kort som</p>
<p><span class="math display">\[
w_1^{\textrm{ny}} \leftarrow w_1 + \eta \cdot \sum_{m=1}^M \delta_w^{(m)} \cdot z^{(m)}
\]</span></p>
<p>På helt tilsvarende vis kan opdateringsreglen for <span class="math inline">\(w_0\)</span> udledes, og vi ender med:</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opdateringsregler for <span class="math inline">\(w\)</span>-vægtene
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p><span class="math display">\[
\begin{aligned}
w_0^{\textrm{ny}} \leftarrow &amp; w_0 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)} \cdot 1\\
w_1^{\textrm{ny}} \leftarrow &amp; w_1 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)} \cdot z^{(m)}\\
\end{aligned}
\]</span> hvor <span class="math display">\[
\delta_w^{(m)} = (t^{(m)}-o^{(m)} ) \cdot o^{(m)}  \cdot (1-o^{(m)})
\]</span></p>
</div>
</div>
</div>
<p>Bemærk her, at fordi vi allerede ved hjælp af feedforward-udtrykkene har beregnet <span class="math inline">\(z^{(m)}\)</span> og <span class="math inline">\(o^{(m)}\)</span>, så alle størrelser, som indgår i ovenstående opdateringsregler, er allerede udregnet.</p>
</section>
<section id="opdatering-af-v-vægtene" class="level3">
<h3 class="anchored" data-anchor-id="opdatering-af-v-vægtene">Opdatering af <span class="math inline">\(v\)</span>-vægtene</h3>
<p>Vi træder nu et skridt tilbage i netværket i <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a> og opdaterer <span class="math inline">\(v\)</span>-vægtene. Gradientnedstigning giver helt generelt følgende opdateringsregler:</p>
<p><span id="eq-generel_opdatering_v"><span class="math display">\[
\begin{aligned}
v_0^{\textrm{ny}} &amp;\leftarrow v_0 - \eta \cdot \frac{\partial E}{\partial v_0} \\
v_1^{\textrm{ny}} &amp;\leftarrow v_1 - \eta \cdot \frac{\partial E}{\partial v_1}
\end{aligned}
\tag{18}\]</span></span></p>
<p>Vi vælger at udlede den sidste regel og skal derfor finde <span class="math inline">\(\frac{\partial E}{\partial v_1}\)</span>. Det kan ses på <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a>, at <span class="math inline">\(v\)</span>-vægtene påvirker tabsfunktionen <span class="math inline">\(E\)</span> først via værdien <span class="math inline">\(z\)</span> og dernæst via outputværdien <span class="math inline">\(o\)</span>. Når vi skal differentiere tabsfunktionen i (<a href="#eq-E" class="quarto-xref">6</a>) med hensyn til <span class="math inline">\(v_1\)</span> kan du derfor igen bruge kædereglen sådan her:</p>
<p><span id="eq-dE_dv1"><span class="math display">\[
\begin{aligned}
\frac{\partial E}{\partial v_1} &amp;=  \sum_{m=1}^M \frac{ \partial E^{(m)}}{\partial v_1} \\
&amp;= \sum_{m=1}^M \frac{ \partial E^{(m)}}{\partial o^{(m)}} \cdot \frac{ \partial o^{(m)}}{\partial z^{(m)} } \cdot \frac{ \partial z^{(m)}}{\partial v_1}
\end{aligned}
\tag{19}\]</span></span></p>
<p>Vi har allerede i (<a href="#eq-dE_do" class="quarto-xref">14</a>) fundet ud af, at</p>
<p><span class="math display">\[
\frac{ \partial E^{(m)}}{\partial o^{(m)}}  = -(t^{(m)}-o^{(m)})
\]</span></p>
<p>Bruger vi feedforward-ligningen i (<a href="#eq-o_m" class="quarto-xref">11</a>):</p>
<p><span class="math display">\[
o^{(m)} = \sigma(w_0 + w_1 \cdot z^{(m)})
\]</span> hvor vi nu differentierer med hensyn til <span class="math inline">\(z^{(m)}\)</span> får vi:</p>
<p><span id="eq-do_dz"><span class="math display">\[
\begin{aligned}
\frac{ \partial o^{(m)}}{\partial z^{(m)} } &amp;= \sigma'(w_0 + w_1 \cdot z^{(m)}) \cdot w_1 \\
&amp;= o^{(m)} \cdot (1-o^{(m)}) \cdot w_1
\end{aligned}
\tag{20}\]</span></span></p>
<p>Her har vi igen brugt den særlige egenskab i (<a href="#eq-afledt_sigmoid" class="quarto-xref">15</a>).</p>
<p>Nu mangler vi blot at bestemme <span class="math inline">\(\frac{ \partial z^{(m)}}{\partial v_1}\)</span>, og her får vi brug for feedward ligningen i (<a href="#eq-z_m" class="quarto-xref">10</a>)</p>
<p><span class="math display">\[
z^{(m)} = \sigma (v_0 + v_1 \cdot y^{(m)}).
\]</span></p>
<p>Derfor er</p>
<p><span id="eq-dz_dv1"><span class="math display">\[
\begin{aligned}
\frac{ \partial z^{(m)}}{\partial v_1} &amp;= \sigma' (v_0 + v_1 \cdot y^{(m)}) \cdot y^{(m)} \\
&amp;= z^{(m)} \cdot (1-z^{(m)}) \cdot y^{(m)}
\end{aligned}
\tag{21}\]</span></span></p>
<p>Igen på grund af (<a href="#eq-afledt_sigmoid" class="quarto-xref">15</a>).</p>
<p>Vi kan nu indsætte (<a href="#eq-dE_do" class="quarto-xref">14</a>), (<a href="#eq-do_dz" class="quarto-xref">20</a>) og (<a href="#eq-dz_dv1" class="quarto-xref">21</a>) i (<a href="#eq-dE_dv1" class="quarto-xref">19</a>) og få</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial E}{\partial v_1} &amp;=  \sum_{m=1}^M \underbrace{-(t^{(m)}-o^{(m)})}_{\frac{\partial E^{(m)}}{\partial o^{(m)}}} \cdot \underbrace{o^{(m)} \cdot (1-o^{(m)}) \cdot w_1}_{\frac{ \partial o^{(m)}}{\partial z^{(m)} }} \cdot \underbrace{z^{(m)} \cdot (1-z^{(m)}) \cdot y^{(m)}}_{\frac{ \partial z^{(m)}}{\partial v_1}} \\
&amp;= - \sum_{m=1}^M \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)}) \cdot y^{(m)}
\end{aligned}
\]</span></p>
<p>da <span class="math display">\[
\delta_w^{(m)} = (t^{(m)}-o^{(m)} ) \cdot o^{(m)}  \cdot (1-o^{(m)}).
\]</span></p>
<p>På tilsvarende vis kan man vise, at</p>
<p><span class="math display">\[
\frac{\partial E}{\partial v_1} = - \sum_{m=1}^M \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)}) \cdot 1
\]</span></p>
<p>Indsættes i (<a href="#eq-generel_opdatering_v" class="quarto-xref">18</a>) får vi altså disse opdateringsregler:</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opdateringsregler for <span class="math inline">\(v\)</span>-vægtene
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p><span class="math display">\[
\begin{aligned}
v_0^{\textrm{ny}} \leftarrow &amp; v_0 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)}\cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot 1\\
v_1^{\textrm{ny}} \leftarrow &amp; v_1 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot y^{(m)}\\
\end{aligned}
\]</span> hvor <span class="math display">\[
\delta_w^{(m)} = (t^{(m)}-o^{(m)} ) \cdot o^{(m)}  \cdot (1-o^{(m)})
\]</span></p>
</div>
</div>
</div>
<p>Her kan vi igen se, at vi på grund af feedforward allerede har beregnet <span class="math inline">\(y^{(m)}\)</span>, <span class="math inline">\(z^{(m)}\)</span> og <span class="math inline">\(o^{(m)}\)</span>.</p>
</section>
<section id="opdatering-af-r-vægtene" class="level3">
<h3 class="anchored" data-anchor-id="opdatering-af-r-vægtene">Opdatering af <span class="math inline">\(r\)</span>-vægtene</h3>
<p>Vi er nu nået til det sidste lag i netværket, som er tættest på inputlaget. Her bliver de generelle opdateringsregler:</p>
<p><span id="eq-generel_opdatering_r"><span class="math display">\[
\begin{aligned}
r_0^{\textrm{ny}} &amp;\leftarrow r_0 - \eta \cdot \frac{\partial E}{\partial r_0} \\
r_1^{\textrm{ny}} &amp;\leftarrow r_1 - \eta \cdot \frac{\partial E}{\partial r_1} \\
&amp; \quad \vdots \\
r_n^{\textrm{ny}} &amp;\leftarrow r_n - \eta \cdot \frac{\partial E}{\partial r_n}
\end{aligned}
\tag{22}\]</span></span></p>
<p>På <a href="#fig-long_simple_NN" class="quarto-xref">figur&nbsp;2</a> ses det, at tabsfunktionen afhænger af disse <span class="math inline">\(r\)</span>-vægte via <span class="math inline">\(o^{(m)}\)</span>, <span class="math inline">\(z^{(m)}\)</span> og <span class="math inline">\(y^{(m)}\)</span>. Der kommer derfor lidt mere fut i kædereglen nu. Den partielle afledede med hensyn til <span class="math inline">\(r_i\)</span> (hvor <span class="math inline">\(i \in \{1, 2, \dots, n\}\)</span>) bliver</p>
<p><span id="eq-dE_dri"><span class="math display">\[
\begin{aligned}
\frac{\partial E}{\partial r_i} &amp;=  \sum_{m=1}^M \frac{ \partial E^{(m)}}{\partial r_i} \\
&amp;= \sum_{m=1}^M \frac{ \partial E^{(m)}}{\partial o^{(m)}} \cdot \frac{ \partial o^{(m)}}{\partial z^{(m)} } \cdot \frac{ \partial z^{(m)}}{\partial y^{(m)}} \cdot \frac{ \partial y^{(m)}}{\partial  r_i}
\end{aligned}
\tag{23}\]</span></span></p>
<p>Nu er vi heldige, for vi har allerede udregnet de to første faktorer i denne sum i (<a href="#eq-dE_do" class="quarto-xref">14</a>) og (<a href="#eq-do_dz" class="quarto-xref">20</a>):</p>
<p><span class="math display">\[
\frac{\partial E^{(m)}}{\partial o^{(m)}} = - (t^{(m)}-o^{(m)})
\]</span></p>
<p>og</p>
<p><span class="math display">\[
\frac{ \partial o^{(m)}}{\partial z^{(m)} } = o^{(m)} \cdot (1-o^{(m)}) \cdot w_1
\]</span></p>
<p>Nu mangler vi bare de to sidste faktorer i (<a href="#eq-dE_dri" class="quarto-xref">23</a>). Feedforward-ligningen i (<a href="#eq-z_m" class="quarto-xref">10</a>) giver</p>
<p><span id="eq-dz_dy"><span class="math display">\[
\begin{aligned}
\frac{\partial z^{(m)}}{\partial y^{(m)}} &amp;= \sigma ' (v_0 + v_1 \cdot y^{(m)}) \cdot v_1 \\
&amp;= z^{(m)} \cdot (1-z^{(m)})\cdot v_1.
\end{aligned}
\tag{24}\]</span></span></p>
<p>Her har vi endnu en gang brugt (<a href="#eq-afledt_sigmoid" class="quarto-xref">15</a>).</p>
<p>Ved hjælp af feedforward-ligningen i (<a href="#eq-y_m" class="quarto-xref">9</a>) kan vi bestemme</p>
<p><span id="eq-dy_dri"><span class="math display">\[
\begin{aligned}
\frac{\partial y^{(m)}}{\partial r_i} &amp;= \sigma '(r_0 + r_1 \cdot x_1^{(m)} + r_2 \cdot x_2^{(m)} + \cdots + r_n \cdot x_n^{(m)}) \cdot x_i^{(m)} \\
&amp;= y^{(m)} \cdot (1-y^{(m)}) \cdot x_i^{(m)}.
\end{aligned}
\tag{25}\]</span></span></p>
<p>Sidste lighedstegn følger af (<a href="#eq-afledt_sigmoid" class="quarto-xref">15</a>) og at</p>
<p><span class="math display">\[
y^{(m)} = \sigma(r_0 + r_1 \cdot x_1^{(m)} + r_2 \cdot x_2^{(m)} + \cdots + r_n \cdot x_n^{(m)}).
\]</span></p>
<p>Bemærk her, at hvis vi differentierer med hensyn til <span class="math inline">\(r_0\)</span>, så bliver</p>
<p><span class="math display">\[
\frac{\partial y^{(m)}}{\partial r_0}=y^{(m)} \cdot (1-y^{(m)}) \cdot 1.
\]</span></p>
<p>Vi kan nu som tidligere indsætte (<a href="#eq-dE_do" class="quarto-xref">14</a>), (<a href="#eq-do_dz" class="quarto-xref">20</a>), (<a href="#eq-dz_dy" class="quarto-xref">24</a>) og (<a href="#eq-dy_dri" class="quarto-xref">25</a>) i (<a href="#eq-dE_dri" class="quarto-xref">23</a>):</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial E}{\partial r_i} =   \sum_{m=1}^M \underbrace{-(t^{(m)}-o^{(m)})}_{\frac{\partial E^{(m)} }{\partial o^{(m)}}} \cdot &amp;\underbrace{o^{(m)} \cdot (1-o^{(m)}) \cdot w_1}_{\frac{\partial o^{(m)}}{\partial z^{(m)}}} \cdot \\ &amp;\underbrace{z^{(m)} \cdot (1-z^{(m)})\cdot v_1}_{\frac{\partial z^{(m)}}{\partial y^{(m)}}} \cdot \underbrace{y^{(m)} \cdot (1-y^{(m)}) \cdot x_i^{(m)}}_{\frac{\partial y^{(m)}}{\partial r_i}}
\end{aligned}
\]</span></p>
<p>Definitionen af <span class="math inline">\(\delta_w^{(m)}\)</span> i (<a href="#eq-delta_m" class="quarto-xref">17</a>) tillader os at forkorte ovenstående en smule:</p>
<p><span class="math display">\[
\frac{\partial E}{\partial r_i} =   - \sum_{m=1}^M \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot v_1 \cdot y^{(m)} \cdot (1-y^{(m)}) \cdot x_i^{(m)}
\]</span> Opdateringsreglen for <span class="math inline">\(r_i\)</span> bliver derfor ifølge (<a href="#eq-generel_opdatering_r" class="quarto-xref">22</a>):</p>
<p><span class="math display">\[
r_i^{\textrm{ny}} \leftarrow r_i + \eta \cdot \sum_{m=1}^M \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot v_1 \cdot y^{(m)} \cdot (1-y^{(m)}) \cdot x_i^{(m)}
\]</span> Og for samtlige <span class="math inline">\(r\)</span>-vægte ender vi med følgende:</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opdateringsregler for <span class="math inline">\(r\)</span>-vægtene
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p><span class="math display">\[
\begin{aligned}
r_0^{\textrm{ny}} &amp;\leftarrow r_0 + \eta \cdot \sum_{m=1}^M \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot v_1 \cdot y^{(m)} \cdot (1-y^{(m)}) \cdot 1 \\
r_1^{\textrm{ny}} &amp;\leftarrow r_1 + \eta \cdot \sum_{m=1}^M \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot v_1 \cdot y^{(m)} \cdot (1-y^{(m)}) \cdot x_1^{(m)} \\
&amp; \quad \vdots \\
r_n^{\textrm{ny}} &amp;\leftarrow r_n + \eta \cdot \sum_{m=1}^M \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot v_1 \cdot y^{(m)} \cdot (1-y^{(m)}) \cdot x_n^{(m)} \\
\end{aligned}
\]</span></p>
<p>hvor <span class="math display">\[
\delta_w^{(m)} = (t^{(m)}-o^{(m)} ) \cdot o^{(m)}  \cdot (1-o^{(m)})
\]</span></p>
</div>
</div>
</div>
<p>Igen har vi – fordi vi forud for opdateringen af vægtene har lavet en feedforward i netværket – udregnet <span class="math inline">\(y^{(m)}\)</span>, <span class="math inline">\(z^{(m)}\)</span> og <span class="math inline">\(o^{(m)}\)</span>, som skal bruges for at beregne ovenstående opdateringer.</p>
</section>
<section id="opsummering-af-backpropagation" class="level3">
<h3 class="anchored" data-anchor-id="opsummering-af-backpropagation">Opsummering af backpropagation</h3>
<p>Vi vil nu lave en samlet opsummering af de tre forskellig opdateringsregler for at få et bedre overblik over, hvad der egentlig sker, når man laver backpropagation.</p>
<p>Opdateringsreglerne for laget tættest på outputlaget (<span class="math inline">\(w\)</span>-vægtene) er:</p>
<p><span class="math display">\[
\begin{aligned}
w_0^{\textrm{ny}} \leftarrow &amp; w_0 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)} \cdot 1\\
w_1^{\textrm{ny}} \leftarrow &amp; w_1 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)} \cdot z^{(m)}\\
\end{aligned}
\]</span> hvor <span class="math display">\[
\delta_w^{(m)} = (t^{(m)}-o^{(m)} ) \cdot o^{(m)}  \cdot (1-o^{(m)})
\]</span></p>
<p>Træder vi et skridt bagud i netværket opdateres <span class="math inline">\(v\)</span>-vægtene således:</p>
<p><span class="math display">\[
\begin{aligned}
v_0^{\textrm{ny}} \leftarrow &amp; v_0 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)}\cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot 1\\
v_1^{\textrm{ny}} \leftarrow &amp; v_1 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot y^{(m)}\\
\end{aligned}
\]</span></p>
<p>Vi ser nu, at <span class="math inline">\(\delta_w^{(m)}\cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\)</span> går igen i begge opdateringsregler. Vi sætter derfor</p>
<p><span id="eq-delta_v"><span class="math display">\[
\delta_v^{(m)} = \delta_w^{(m)}\cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)}).
\tag{26}\]</span></span></p>
<p>Opdateringen af <span class="math inline">\(v\)</span>-vægtene kan derfor skrives på denne måde:</p>
<p><span class="math display">\[
\begin{aligned}
v_0^{\textrm{ny}} \leftarrow &amp; v_0 + \eta \cdot \sum_{m=1}^{M} \delta_v^{(m)}\cdot 1\\
v_1^{\textrm{ny}} \leftarrow &amp; v_1 + \eta \cdot \sum_{m=1}^{M} \delta_v^{(m)}\cdot y^{(m)}\\
\end{aligned}
\]</span></p>
<p>De sidste opdateringsregler for <span class="math inline">\(r\)</span>-vægtene ser sådan her ud:</p>
<p><span class="math display">\[
r_i^{\textrm{ny}} \leftarrow r_i + \eta \cdot \sum_{m=1}^M \delta_w^{(m)} \cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)})\cdot v_1 \cdot y^{(m)} \cdot (1-y^{(m)}) \cdot x_i^{(m)}
\]</span></p>
<p>Indsætter vi udtrykket i (<a href="#eq-delta_v" class="quarto-xref">26</a>) kan det forkortes til:</p>
<p><span class="math display">\[
r_i^{\textrm{ny}} \leftarrow r_i + \eta \cdot \sum_{m=1}^M \delta_v^{(m)} \cdot v_1 \cdot y^{(m)} \cdot (1-y^{(m)}) \cdot x_i^{(m)}
\]</span> Og lader vi</p>
<p><span class="math display">\[
\delta_r^{(m)} = \delta_v^{(m)} \cdot v_1 \cdot y^{(m)} \cdot (1-y^{(m)})
\]</span></p>
<p>ender vi med</p>
<p><span class="math display">\[
r_i^{\textrm{ny}} \leftarrow r_i + \eta \cdot \sum_{m=1}^M \delta_r^{(m)} \cdot x_i^{(m)}
\]</span></p>
<p>Det fine er, at det nu er blevet meget tydeligt, at alle opdateringsregler faktisk minder ret meget om hinanden. Vi kan derfor sammenfatte opdateringsreglener på denne måde:</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Backpropagation
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Backpropagation foregår samlet set på denne måde:</p>
<ol type="1">
<li><p>Sæt alle vægtene til en tilfældig værdi og vælg en værdi for learning raten <span class="math inline">\(\eta\)</span>.</p></li>
<li><p>For alle træningsdataeksempler udregnes <span class="math inline">\(y^{(m)}\)</span>, <span class="math inline">\(z^{(m)}\)</span> og <span class="math inline">\(o^{(m)}\)</span> ved hjælp af feedforward-udtrykkene:</p>
<p><span class="math display">\[
\begin{aligned}
y^{(m)} &amp;= \sigma (r_0 + r_1 \cdot x_1^{(m)} + r_2 \cdot x_2^{(m)} + \cdots + r_n \cdot x_n^{(m)})  \\
z^{(m)} &amp;= \sigma (v_0 + v_1 \cdot y^{(m)})  \\
o^{(m)} &amp;= \sigma(w_0 + w_1 \cdot z^{(m)})
\end{aligned}
\]</span></p></li>
<li><p>Udregn følgende:</p>
<p><span class="math display">\[
\begin{aligned}
\delta_w^{(m)} &amp;= (t^{(m)}-o^{(m)} ) \cdot o^{(m)}  \cdot (1-o^{(m)})  \\
\delta_v^{(m)} &amp;= \delta_w^{(m)}\cdot w_1 \cdot z^{(m)} \cdot (1-z^{(m)}) \\
\delta_r^{(m)} &amp;= \delta_v^{(m)} \cdot v_1 \cdot y^{(m)} \cdot (1-y^{(m)})
\end{aligned}
\]</span> Bemærk her, at vi kender <span class="math inline">\(y^{(m)}\)</span>, <span class="math inline">\(z^{(m)}\)</span> og <span class="math inline">\(o^{(m)}\)</span> på grund af feedforward, mens <span class="math inline">\(w_1\)</span> og <span class="math inline">\(v_1\)</span> er de nuværende værdier af vægtene (<em>inden</em> opdatering). Bemærk også, at for at beregne <span class="math inline">\(\delta_v^{(m)}\)</span> må vi først have beregnet <span class="math inline">\(\delta_w^{(m)}\)</span> (som hører til det sidste lag). Tilsvarende for at beregne <span class="math inline">\(\delta_r^{(m)}\)</span> må vi først have beregnet <span class="math inline">\(\delta_v^{(m)}\)</span> (som hører til det næstsidste lag). Det er derfor, at algoritmen hedder <strong>back</strong>propagation.</p></li>
<li><p>Vægtene opdatereres:</p>
<p><strong><span class="math inline">\(w\)</span>-vægtene:</strong> <span class="math display">\[
\begin{aligned}
w_0^{\textrm{ny}} &amp;\leftarrow w_0 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)} \cdot 1\\
w_1^{\textrm{ny}} &amp;\leftarrow w_1 + \eta \cdot \sum_{m=1}^{M} \delta_w^{(m)} \cdot z^{(m)}\\
\end{aligned}
\]</span> <strong><span class="math inline">\(v\)</span>-vægtene:</strong> <span class="math display">\[
\begin{aligned}
v_0^{\textrm{ny}} &amp;\leftarrow v_0 + \eta \cdot \sum_{m=1}^{M} \delta_v^{(m)}\cdot 1\\
v_1^{\textrm{ny}} &amp;\leftarrow v_1 + \eta \cdot \sum_{m=1}^{M} \delta_v^{(m)}\cdot y^{(m)}\\
\end{aligned}
\]</span> <strong><span class="math inline">\(r\)</span>-vægtene:</strong> <span class="math display">\[
\begin{aligned}
r_0^{\textrm{ny}} &amp;\leftarrow r_0 + \eta \cdot \sum_{m=1}^M \delta_r^{(m)} \cdot 1 \\
r_1^{\textrm{ny}} &amp;\leftarrow r_1 + \eta \cdot \sum_{m=1}^M \delta_r^{(m)} \cdot x_1^{(m)} \\
&amp; \quad \vdots \\
r_n^{\textrm{ny}} &amp;\leftarrow r_n + \eta \cdot \sum_{m=1}^M \delta_r^{(m)} \cdot x_n^{(m)}
\end{aligned}
\]</span></p></li>
</ol>
<p>Alle vægtene er nu opdateret, og vi kan gentage punkt 2 til 4, hvor feedforward i 2 hver gang er baseret på de netop opdaterede vægte fra det foregående gennemløb. Opdateringen af vægtene fortsætter indtil værdien af tabsfunktionen næsten ikke ændrer sig. Håbet er nu, at vi har fundet et minimum (eventuelt kun lokalt) for tabsfunktionen.</p>
</div>
</div>
</div>
</section>
</section>
<section id="og-hvor-blev-den-vejrudsigt-så-af" class="level2">
<h2 class="anchored" data-anchor-id="og-hvor-blev-den-vejrudsigt-så-af">Og hvor blev den vejrudsigt så af?</h2>
<p>Vi tog jo egentlig udgangspunkt i et eksempel om at forudsige vejret, men hvis du har læst med så langt, er du sikkert ikke en gang klar over, om solen skinner, eller det regner lige nu! Så lad os lige prøve at zoome ud og komme tilbage til den vejrudsigt.</p>
<p>Vi havde de fire inputvariable:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;x_1: \textrm{Er det regnvejr i dag? Hvis 'ja' er } x_1=1 \textrm{ og } 0 \textrm{ ellers.} \\
&amp;x_2: \textrm{Luftfugtigheden i dag.} \\
&amp;x_3: \textrm{Temperaturen i dag.} \\
&amp;x_4: \textrm{Lufttrykket i dag.} \\
\end{aligned}
\]</span></p>
<p>Vi forestiller os, at vi har samlet et stort træningsdatasæt, som beskrevet i afsnittet <a href="../../materialer/simple_neurale_net/simple_neurale_net.html#træningsdata-og-tabsfunktion">Træningsdata og tabsfunktion</a>. Herefter bruger vi træningsdata og backpropagation, som gennemgået ovenfor, til at bestemme værdier af vægtene <span class="math inline">\(w_0, w_1, v_0, v_1, r_0, r_1, \dots, r_n\)</span>, så tabsfunktionen minimeres.</p>
<p>Så står vi her i dag og vil gerne forudsige vejret i morgen. Kig lige ud af vinduet. Regner det eller ej? Mål luftfugtigheden, temperaturen og lufttrykket. Du har nu fire konkret værdier af <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span>, <span class="math inline">\(x_3\)</span> og <span class="math inline">\(x_4\)</span>. Nu bruger du feedforward-udtrykkene i (<a href="#eq-y" class="quarto-xref">3</a>), (<a href="#eq-z" class="quarto-xref">4</a>) og (<a href="#eq-o" class="quarto-xref">5</a>) til at beregne outputværdien <span class="math inline">\(o\)</span>.</p>
<p><img src="images/paraply.jpg" class="img-fluid" style="float:right;;width:20.0%"></p>
<ul>
<li><p>Er <span class="math inline">\(o \geq 0.5\)</span>? Find paraplyen frem – din højteknologiske og banebrydende vejrudsigt forudsiger, at det bliver regnvejr i morgen.</p></li>
<li><p>Er <span class="math inline">\(o&lt;0.5\)</span>? No worries – i morgen bliver det ikke regnvejr. Så lad bare paraplyen stå.</p></li>
</ul>
<p>Det var faktisk "bare" det. Sådan kan man altså bruge kunstig intelligens til at forudsige vejret (og så kan du nok godt forestille dig, at i virkelighedens verden, er det hele lidt mere kompliceret).</p>
</section>
<section id="relaterede-forløb" class="level2">
<h2 class="anchored" data-anchor-id="relaterede-forløb">Relaterede forløb</h2>
<div id="listing-main-listing-content" class="quarto-listing quarto-listing-container-table">
<table class="quarto-listing-table table">
<thead>
<tr>

<th>
Forløb
</th>

<th>
Kort beskrivelse
</th>

</tr>
</thead>
<tbody class="list">

<tr data-index="0" data-categories="QS1uaXZlYXUlMkNLb3J0" data-listing-file-modified-sort="1754521957469" data-listing-reading-time-sort="2" data-listing-word-count-sort="301" data-listing-title-sort="Aktiveringsfunktioner" data-listing-filename-sort="aktiveringsfunktioner.qmd">
<td>
<a href="../../undervisningsforlob/aktiveringsfunktioner.html" class="title listing-title">Aktiveringsfunktioner</a>
</td>
<td>
<span class="listing-description-meta">I opbygningen af kunstige neurale netværk er aktiveringsfunktioner helt centrale. Og aktiveringsfunktioner skal differentieres – det handler dette forløb om.</span>
</td>

</tr>

<tr data-index="1" data-categories="QS1uaXZlYXUlMkNCaW90ZWtub2xvZ2klMkNLb3J0" data-listing-file-modified-sort="1754521958259" data-listing-reading-time-sort="1" data-listing-word-count-sort="149" data-listing-title-sort="Screeningsprogrammer" data-listing-filename-sort="screeningsprogrammer.qmd">
<td>
<a href="../../undervisningsforlob/screeningsprogrammer.html" class="title listing-title">Screeningsprogrammer</a>
</td>
<td>
<span class="listing-description-meta">Kan man lave screeningsprogrammer for sygdomme baseret på genetiske markører med brug af AI? Det undersøger vi i dette forløb, som med fordel kan foregå i et samarbejde med bioteknologi.</span>
</td>

</tr>

<tr data-index="2" data-categories="QS1uaXZlYXUlMkNLb3J0" data-listing-file-modified-sort="1754521957860" data-listing-reading-time-sort="3" data-listing-word-count-sort="576" data-listing-title-sort="Opklar et mord!" data-listing-filename-sort="opklar_et_mord.qmd">
<td>
<a href="../../undervisningsforlob/opklar_et_mord.html" class="title listing-title">Opklar et mord!</a>
</td>
<td>
<span class="listing-description-meta">Der er blevet begået et mord på skolen i nat. Det er jeres opgave at opklare det!</span>
</td>

</tr>

<tr data-index="3" data-categories="QS1uaXZlYXUlMkNLb3J0" data-listing-file-modified-sort="1754521957460" data-listing-reading-time-sort="6" data-listing-word-count-sort="1192" data-listing-title-sort="Opdatering af vægte i et simpelt neuralt netværk med to skjulte lag" data-listing-filename-sort="Opdatering_af_vægte_i_NN_med_2_skjulte_lag.qmd">
<td>
<a href="../../undervisningsforlob/Opdatering_af_vægte_i_NN_med_2_skjulte_lag.html" class="title listing-title">Opdatering af vægte i et simpelt neuralt netværk med to skjulte lag</a>
</td>
<td>
<span class="listing-description-meta">En øvelse i at opdatere vægtene i et simpelt neuralt netværk med to skjulte lag.</span>
</td>

</tr>

<tr data-index="4" data-categories="QS1uaXZlYXUlMkNLb3J0" data-listing-file-modified-sort="1754521957460" data-listing-reading-time-sort="4" data-listing-word-count-sort="703" data-listing-title-sort="Opdatering af vægte i et simpelt neuralt netværk med ét skjult lag (men med *cross-entropy* som tabsfunktion)" data-listing-filename-sort="Opdatering_af_vægte_i_NN_med_1_skjult_lag.qmd">
<td>
<a href="../../undervisningsforlob/Opdatering_af_vægte_i_NN_med_1_skjult_lag.html" class="title listing-title">Opdatering af vægte i et simpelt neuralt netværk med ét skjult lag (men med <em>cross-entropy</em> som tabsfunktion)</a>
</td>
<td>
<span class="listing-description-meta">En øvelse i at opdatere vægtene i et neuralt netværk med ét skjult lag med <em>cross-entropy</em> som tabsfunktion.</span>
</td>

</tr>

</tbody>
</table>
<div class="listing-no-matching d-none">No matching items</div>
</div>



</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/aimat\.dk");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>