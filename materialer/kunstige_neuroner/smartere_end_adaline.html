<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>smartere_end_adaline – AI MAT - matematikken bag magien</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo/SVG/Bomaerke_05_AIMAT_2024.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-c8ad9e5dbd60b7b70b38521ab19b7da4.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-117cf6564b43f3aeecf187829027ef13.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Y219BCPS45"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
 
  gtag('consent', 'default', {
    'ad_storage': 'denied',
    'analytics_storage': 'denied'
  });
gtag('config', 'G-Y219BCPS45', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo/PNG/Logo_multi_AIMAT_RGB_2024.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../undervisningsforlob/index.html"> 
<span class="menu-text">Undervisningsforløb</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../materialer/index.html"> 
<span class="menu-text">Materialer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../srp/index.html"> 
<span class="menu-text">SRP</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../apps/index.html"> 
<span class="menu-text">Apps</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Om os</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.youtube.com/@ai-mat"> 
<span class="menu-text"><img src="../../logo/YouTube/youtube-color-darkblue-icon.svg" style="height:2em"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Indhold</h2>
   
  <ul>
  <li><a href="#hvorfor-er-kunstige-neuroner-smartere-end-adaline" id="toc-hvorfor-er-kunstige-neuroner-smartere-end-adaline" class="nav-link active" data-scroll-target="#hvorfor-er-kunstige-neuroner-smartere-end-adaline">Hvorfor er kunstige neuroner smartere end ADALINE?</a></li>
  <li><a href="#kunstige-neuroner-og-aktiveringsfunktioner" id="toc-kunstige-neuroner-og-aktiveringsfunktioner" class="nav-link" data-scroll-target="#kunstige-neuroner-og-aktiveringsfunktioner">Kunstige neuroner og aktiveringsfunktioner</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="hvorfor-er-kunstige-neuroner-smartere-end-adaline" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="hvorfor-er-kunstige-neuroner-smartere-end-adaline">Hvorfor er kunstige neuroner smartere end ADALINE?</h2>
<p>I noten om <a href="../../materialer/perceptron/perceptron.html">perceptroner</a> beskrev vi <a href="../../materialer/perceptron/perceptron.html#sec-perceptron_learning_algortimen">perceptron learning algoritmen</a>, som altid konvergerer, hvis data er lineært separabel. Men verden er sjældent lineært separabel, og derfor introducerede vi <a href="../../materialer/perceptron/perceptron.html#sec-ADALINE">ADALINE algoritmen</a>, som også virker, selvom data ikke er lineært separabel. I noten om <a href="../../materialer/kunstige_neuroner/kunstige_neuroner.html">kunstige neuroner</a> beskrev vi en helt tredje metode.</p>
<p>Vi vil her med et enkelt lille eksempel afsløre, at ADALINE ikke altid er så smart, som man kunne tro. Dernæst vil vi forklare hvordan kunstige neuroner, kan være en løsning på det skitserede problem.</p>
<p>Vi vil se på data i nedenstående tabel</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(x_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(x_2\)</span></th>
<th style="text-align: center;">Targetværdi</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(-0.5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(-0.3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(-0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.7\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(-0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-1\)</span></td>
</tr>
</tbody>
</table>
<p>Bemærk, at i ADALINE er targetværdien <span class="math inline">\(t \in \{-1,1\}\)</span>.</p>
<p>I <a href="#fig-eks1" class="quarto-xref">figur&nbsp;1</a> har vi indtegnet punkterne <span class="math inline">\((x_1,x_2)\)</span> og farvet punkterne med en targetværdi på <span class="math inline">\(1\)</span> blå og dem med en targetværdi på <span class="math inline">\(-1\)</span> røde.</p>
<div id="fig-eks1" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-eks1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/fig-eks1.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-eks1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;1: Punkter med en targetværdi på <span class="math inline">\(1\)</span> er blå og dem med en targetværdi på <span class="math inline">\(-1\)</span> er røde.
</figcaption>
</figure>
</div>
<p>Det er tydeligt, at punkterne er lineært separable og den indtegnede linje er også den som ADALINE giver<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Du kan selv prøve <a href="https://apps01.math.aau.dk/ai/neuron/">ADALINE her</a> (sørg blot for at vælge "Identitet" som aktiveringsfunktion under fanen "Træning"). De estimerede vægte er <span class="math inline">\(w_0=-0.9346, w_1=-2.838\)</span> og <span class="math inline">\(w_2=1.668\)</span>.Det vil sige, at den indtegnede linje har ligning</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Her er alle startvægte sat til <span class="math inline">\(0\)</span>, learning rate er på <span class="math inline">\(0.1\)</span>, stop-kriterie er på <span class="math inline">\(0.000001\)</span> og maksimalt antal iterationer er sat til <span class="math inline">\(50000\)</span>.</p></div></div><p><span class="math display">\[
-0.9346-2.838 x_1 + 1.668x_2=0
\]</span></p>
<p>Det er alt sammen meget fint, men lad os nu prøve at indtegne et nyt rødt punkt:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(x_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(x_2\)</span></th>
<th style="text-align: center;">Targetværdi</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-1\)</span></td>
</tr>
</tbody>
</table>
<p>Det nye punkt er indtegnet i <a href="#fig-eks2" class="quarto-xref">figur&nbsp;2</a> sammen med de øvrige seks punkter. Det er tydeligt, at data stadig er lineært separabel.</p>
<div id="fig-eks2" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-eks2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/fig-eks2.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-eks2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;2: Et nyt rødt punkt er indtegnet og data er stadig lineært separabel.
</figcaption>
</figure>
</div>
<p>Hvis vi prøver at køre ADALINE algoritmen fås linjen, som er indtegnet i <a href="#fig-eks2_2" class="quarto-xref">figur&nbsp;3</a>. Vi kan allerede se nu, at det er helt skørt. Data er lineært separabel, men alligevel er der et rødt punkt, som bliver klassificeret forkert – faktisk var den oprindelige linje fra <a href="#fig-eks1" class="quarto-xref">figur&nbsp;1</a> bedre.</p>
<div id="fig-eks2_2" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-eks2_2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/fig-eks2_2.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-eks2_2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;3: Et nyt rødt punkt er indtegnet og den linje, som ADALINE finder.
</figcaption>
</figure>
</div>
<p>Det er jo ikke ligefrem super overbevisende. Data er lineært separabel og alligevel kan ADALINE ikke finde ud af at finde en ret linje, som kan adskille de røde punkter fra de blå!</p>
<p>Hvis vi skal forstå, hvad der sker, må vi se lidt nærmere på den tabsfunktion, som ADALINE forsøger at mininere. Fra <a href="../../materialer/perceptron/perceptron.html#sec-ADALINE">afsnittet om ADALINE</a> ved vi, at tabsfunktionen<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> er</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;Bemærk her, at det ikke er afgørende, at der er ganget med <span class="math inline">\(1/2\)</span> – det viser sig bare smartere senere.</p></div></div><p><span id="eq-tabsfuntion"><span class="math display">\[
\begin{aligned}
E(w_0, w_1, &amp;\dots, w_n)\\ &amp;= \frac{1}{2} \sum_{m=1}^{M} \left (t^{(m)}-
(w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}) \right)^2
\end{aligned}
\tag{1}\]</span></span></p>
<p>hvor det <span class="math inline">\(m\)</span>’te træningseksempel er <span class="math display">\[(x_1^{(m)}, x_2^{(m)}, \dots, x_n^{(m)}, t^{(m)})\]</span></p>
<p>Det vil sige, at det <span class="math inline">\(m\)</span>’te træningseksempel giver et bidrag til tabsfunktionen på</p>
<p><span class="math display">\[
\left ( t^{(m)}- (w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}) \right)^2
\]</span></p>
<p>For et blåt punkt med <span class="math inline">\(t^{(m)}=1\)</span> vil det sige, at bidraget til tabsfunktionen er præcis <span class="math inline">\(0,\)</span> hvis <span class="math display">\[
1- \left (w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)} \right) =0
\]</span> og for et rødt punkt med <span class="math inline">\(t^{(m)}=-1\)</span> er bidraget til tabsfunktionen præcis <span class="math inline">\(0,\)</span> hvis <span class="math display">\[
-1- \left (w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)} \right)=0
\]</span> Nu er <span class="math inline">\(1- (w_0 + w_1 \cdot x_1 + \cdots + w_n \cdot x_n)=0\)</span> og <span class="math inline">\(-1- (w_0 + w_1 \cdot x_1 + \cdots + w_n \cdot x_n)=0\)</span> jo bare ligninger for rette linjer<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Disse linjer ses indtegnet på <a href="#fig-eks1_2" class="quarto-xref">figur&nbsp;4</a> (som henholdsvis en blå og rød stiplet linje) sammen med de oprindelige seks punkter og den linje, som ADALINE fandt baseret på disse seks punkter. Samtidig er det for hvert punkt markeret, hvor meget dette punkt bidrager til tabsfunktionen.</p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;Det er i hvert tilfælde "bare linjer", når <span class="math inline">\(n=2\)</span>. Hvis <span class="math inline">\(n=3\)</span>, er der tale om ligningen for en plan, og hvis <span class="math inline">\(n&gt;3\)</span>, kalder man det for ligningen for en "hyperplan". Men sidstnævnte er visuelt svære at forestille sig, fordi koordinatsystemet, disse hyperplaner skal tegnes i, har en dimension større end <span class="math inline">\(3\)</span>. Og de er ikke så nemme at tegne!</p></div></div><div id="fig-eks1_2" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-eks1_2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/fig-eks1_2.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-eks1_2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;4: Punkter med en targetværdi på <span class="math inline">\(1\)</span> er blå og dem med en targetværdi på <span class="math inline">\(-1\)</span> er røde. Den sorte linje med ligning <span class="math inline">\(w_0+w_1 x_1 + w_2 x_2=0\)</span> svarer til den ADALINE fandt. Den blå stiplede linje har ligning <span class="math inline">\(1-(w_0+w_1 x_1 + w_2 x_2)=0\)</span>, mens den røde stiplede linje har ligning <span class="math inline">\(-1-(w_0+w_1 x_1 + w_2 x_2)=0\)</span>.
</figcaption>
</figure>
</div>
<p>Det ses nu på <a href="#fig-eks1_2" class="quarto-xref">figur&nbsp;4</a>, at blå punkter, som ligger tæt på den blå stiplede linje, bidrager mindst til tabsfunktionen, mens røde punkter, som ligger tæt på den røde stiplede linje, ligeledes bidrager mindst til tabsfunktionen. Den samlede værdi af tabsfunktionen<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> er her <span class="math inline">\(0.75\)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;Værdien udregnes ved at lægge alle bidragene sammen og gange med <span class="math inline">\(\frac{1}{2}\)</span>. Jævnfør udtrykket for tabsfunktionen i (<a href="#eq-tabsfuntion" class="quarto-xref">1</a>).</p></div></div><p>Laver vi nu samme øvelse med det ekstra punkt fås resultat i <a href="#fig-eks2_4" class="quarto-xref">figur&nbsp;5</a>.</p>
<div id="fig-eks2_4" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-eks2_4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/fig-eks2_4.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-eks2_4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;5: I alt syv punkter sammen med den sorte linje med ligning <span class="math inline">\(w_0+w_1 x_1 + w_2 x_2=0\)</span> svarer til den ADALINE finder. Punkter med en targetværdi på <span class="math inline">\(1\)</span> er blå og dem med en targetværdi på <span class="math inline">\(-1\)</span> er røde. Den blå stiplede linje har ligning <span class="math inline">\(1-(w_0+w_1 x_1 + w_2 x_2)=0\)</span>, mens den røde stiplede linje har ligning <span class="math inline">\(-1-(w_0+w_1 x_1 + w_2 x_2)=0\)</span>. Den samlede værdi af tabsfunktionen er her <span class="math inline">\(2.00\)</span>.
</figcaption>
</figure>
</div>
<p>Igen ser vi, at blå punkter tæt på den blå stiplede linje bidrager mindst til tabsfunktionen og tilsvarende for de røde punkter, som ligger tæt på den røde stiplede linje. Det nye punkts bidrag til tabsfunktionen bliver derfor her det mindste bidrag blandt alle de røde punkter. Den samlede værdi af tabsfunktionen er her <span class="math inline">\(2.00\)</span>.</p>
<p>Hvis vi i stedet prøver at bruge vores egen oprindelige linje (baseret på de seks første punkter), som rent faktisk kunne adskille de blå punkter fra de røde, så fås det resultat, som ses i <a href="#fig-eks2_med_oprindelig_linje" class="quarto-xref">figur&nbsp;6</a>.</p>
<div id="fig-eks2_med_oprindelig_linje" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-eks2_med_oprindelig_linje-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/eks2_med_oprindelig_linje.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-eks2_med_oprindelig_linje-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;6: I alt syv punkter sammen med den sorte linje, som ADALINE giver baseret på de oprindelige seks punkter. Punkter med en targetværdi på <span class="math inline">\(1\)</span> er blå og dem med en targetværdi på <span class="math inline">\(-1\)</span> er røde. Den blå stiplede linje har ligning <span class="math inline">\(1-(w_0+w_1 x_1 + w_2 x_2)=0\)</span>, mens den røde stiplede linje har ligning <span class="math inline">\(-1-(w_0+w_1 x_1 + w_2 x_2)=0\)</span>. Den samlede værdi af tabsfunktionen er her <span class="math inline">\(10.60\)</span>.
</figcaption>
</figure>
</div>
<p>Det er nu tydeligt, at det nye røde punkter ligger så langt væk fra den stiplede røde linje, at det bidrager betydeligt til tabsfunktionen. Derfor er den samlede værdi af tabsfunktionen <span class="math inline">\(10.60\)</span> – og derfor vælger ADALINE linjen i <a href="#fig-eks2_4" class="quarto-xref">figur&nbsp;5</a> til at adskille punkterne. Ikke fordi, det er den linje, som giver den laveste andel af korrekt klassificerede, men fordi det er den linje, som minimerer tabsfunktionen! Det kan jo godt virke lidt skørt, når vi selv kan indtegne en linje, som kan separere alle punkterne.</p>
</section>
<section id="kunstige-neuroner-og-aktiveringsfunktioner" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="kunstige-neuroner-og-aktiveringsfunktioner">Kunstige neuroner og aktiveringsfunktioner</h2>
<p>Problemet med ADALINE, som vi har set i eksemplet ovenfor, opstår fordi, et <em>ekstremt</em> punkt får lov til at "trække" uforholdsmæssigt meget i den linje, som ADALINE finder, for at dette punkts bidrag til tabsfunktionen ikke skal blive alt for stort.</p>
<p>Vi så det i <a href="#fig-eks2_4" class="quarto-xref">figur&nbsp;5</a> og <a href="#fig-eks2_med_oprindelig_linje" class="quarto-xref">figur&nbsp;6</a>. I <a href="#fig-eks2_4" class="quarto-xref">figur&nbsp;5</a> brugte vi den linje, som ADALINE gav, og her var det <em>ekstreme</em> punkts bidrag til tabsfunktionen på <span class="math inline">\(0.32\)</span>. I <a href="#fig-eks2_med_oprindelig_linje" class="quarto-xref">figur&nbsp;6</a> valgte vi en linje, som oplagt er bedre til at adskille de blå punkter fra de røde, men her er det <em>ekstreme</em> punkts bidrag til tabsfunktionen helt oppe på <span class="math inline">\(19.72\)</span>.</p>
<p>For at forstå det lidt bedre skal vi måske lige repetere, hvordan man finder afstanden fra et punkt <span class="math inline">\(P(x_1,y_1)\)</span> til en linje <span class="math inline">\(l\)</span> med ligning <span class="math inline">\(ax+by+c=0\)</span>:</p>
<p><span class="math display">\[
\textrm{dist}(P,l)=\frac{|a x_1 + b y_1 +c|}{\sqrt{a^2+b^2}}
\]</span></p>
<p>Denne afstandsformel kan generaliseres, så afstanden fra et punkt <span class="math inline">\(P(x_1^{(m)}, x_2^{(m)}, \dots, x_n^{(m)})\)</span> (i et <span class="math inline">\(n\)</span>-dimensionalt rum!) til planen <span class="math inline">\(\alpha\)</span> med ligning <span class="math inline">\(w_0+w_1 x_1 + w_2 x_2 + \cdots + w_n x_n=0\)</span> er:</p>
<p><span class="math display">\[
\textrm{dist}(P,\alpha)=\frac{\left | w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)} \right |}{\sqrt{w_1^2 + w_2^2 + \cdots + w_n^2}}
\]</span></p>
<p>Det vil sige, at udtrykket i tælleren <span class="math inline">\(|w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}|\)</span> bliver et mål for hvor langt væk punktet <span class="math inline">\(P(x_1^{(m)}, x_2^{(m)}, \dots, x_n^{(m)})\)</span> ligger fra planen. Det forklarer, hvordan et <em>ekstremt</em> punkt kan give et meget stort bidrag til tabsfunktionen:</p>
<p><span id="eq-bidrag_til_tabsfunktion"><span class="math display">\[
\left ( t^{(m)}- (w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}) \right)^2
\tag{2}\]</span></span></p>
<p>Hvis punktet ligger langt væk fra den plan, som måske umiddelbart ser fornuftig ud, så vil punktet give et stort bidrag til tabsfunktionen, fordi værdien af <span class="math inline">\(w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}\)</span> bliver stor, og dermed vil bidraget til tabsfunktionen i (<a href="#eq-bidrag_til_tabsfunktion" class="quarto-xref">2</a>) også blive stort!</p>
<p>Alt det her leder os frem til, at valget af tabsfunktion måske i virkeligheden ikke er super smart. Problemet opstår grundlæggende, fordi targetværdien <span class="math inline">\(t\)</span> og udtrykket i den inderste parentes i (<a href="#eq-bidrag_til_tabsfunktion" class="quarto-xref">2</a>) er på to helt vidt forskellige skalaer. Targetværdien er enten <span class="math inline">\(-1\)</span> eller <span class="math inline">\(1\)</span>, mens udtrykket <span class="math inline">\(w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}\)</span> kan antage en hvilken som helst reel værdi – en værdi som kan blive vældig stor, hvis punktet <span class="math inline">\(P(x_1^{(m)}, x_2^{(m)}, \dots, x_n^{(m)})\)</span> ligger langt væk fra planen. Derfor bliver ADALINE nødt til at tvinge planen med ligningen</p>
<p><span class="math display">\[
w_0 + w_1 \cdot x_{1} + \cdots + w_n \cdot x_{n}=0
\]</span></p>
<p>over mod et ekstremt punkt, sådan at dette punkts bidrag til tabsfunktionen ikke bliver alt for stort.</p>
<p>Problemet kan løses ved at bruge en <a href="../../materialer/kunstige_neuroner/kunstige_neuroner.html">kunstig neuron</a>.</p>
<p>Helt grundlæggende handler problemet om, at targetværdi <span class="math inline">\(t,\)</span> og det udtryk, som vi beregner på baggrund af punktet <span class="math inline">\(P(x_1^{(m)}, x_2^{(m)}, \dots, x_n^{(m)})\)</span>, skal være på samme skala. I den kunstige neuron brugte vi sigmoid-funktionen <span class="math inline">\(\sigma\)</span>, som aktiveringsfunktion. Forskriften for sigmoid-funktionen er:</p>
<p><span id="eq-sigmoid"><span class="math display">\[
\sigma(x)=\frac{1}{1+\mathrm{e}^{-x}}
\tag{3}\]</span></span></p>
<p>og grafen ses i <a href="#fig-sigmoid" class="quarto-xref">figur&nbsp;7</a>.</p>
<div id="fig-sigmoid" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/sigmoid.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;7: Grafen for sigmoid-funktionen med forskrift <span class="math inline">\(\sigma(x)=\frac{1}{1+\mathrm{e}^{-x}}\)</span>.
</figcaption>
</figure>
</div>
<p>Det centrale her er værdimængden for sigmoid-funktion:</p>
<p><span class="math display">\[
Vm(\sigma)=(0,1).
\]</span></p>
<p>Det vil vi udnytte og nu omdefinere targetværdien <span class="math inline">\(t\)</span> på denne måde:</p>
<p><span class="math display">\[
t=
\begin{cases}
1 &amp; \textrm{hvis punktet er blåt} \\
0 &amp; \textrm{hvis punktet er rødt} \\
\end{cases}
\]</span></p>
<p>Så targetværdierne er nu <span class="math inline">\(0\)</span> eller <span class="math inline">\(1\)</span> i stedet for <span class="math inline">\(-1\)</span> og <span class="math inline">\(1\)</span>. Vi husker nu, hvordan vi definerede tabsfunktionen for de kunstige neuroner:</p>
<p><span id="eq-ny_tabsfunktion"><span class="math display">\[
\begin{aligned}
E(w_0, w_1, &amp;\dots, w_n) \\ &amp;= \frac{1}{2} \sum_{m=1}^{M} \left (t^{(m)}-
\sigma(w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)}) \right)^2
\end{aligned}
\tag{4}\]</span></span></p>
<p>Bemærk, at problemet med de to skalaer nu er løst. Targetværdien er enten <span class="math inline">\(0\)</span> eller <span class="math inline">\(1\)</span> samtidig med, at <span class="math inline">\(\sigma(w_0 + w_1 \cdot x_1^{(m)} + \cdots + w_n \cdot x_n^{(m)})\)</span> også ligger mellem <span class="math inline">\(0\)</span> og <span class="math inline">\(1\)</span>. Vi sammenligner altså ikke længere pærer med bananer! Den "perceptron", som minimerer tabsfunktionen i (<a href="#eq-ny_tabsfunktion" class="quarto-xref">4</a>), er netop det, vi kalder for en <strong>kunstig neuron</strong>.</p>
<p>I noten om <a href="../../materialer/kunstige_neuroner/kunstige_neuroner.html">kunstige neuroner</a> beskrev vi, hvordan vi kan tænke på outputværdien</p>
<p><span class="math display">\[
o = \sigma(w_0 + w_1 \cdot x_1 + \cdots + w_n \cdot x_n)
\]</span></p>
<p>som en sandsynlighed for at punktet <span class="math inline">\(P(x_1, x_2, \dots, x_n)\)</span> er blåt. Det gjorde vi på denne måde:</p>
<p><span id="eq-pred"><span class="math display">\[
\textrm{Nyt punkt }=
\begin{cases}
\textrm{blåt} &amp; \textrm{hvis } o \geq 0.5\\
\textrm{rødt} &amp; \textrm{hvis } o &lt; 0.5\\
\end{cases}
\tag{5}\]</span></span></p>
<p>hvor</p>
<p><span class="math display">\[
o = \sigma(w_0 + w_1 \cdot x_1 + \cdots + w_n \cdot x_n).
\]</span></p>
<p>Vi argumenterede også for, at skillelinjen, for hvornår et punkt <span class="math inline">\((x_1, x_2, \dots, x_n)\)</span> er blåt eller rødt, kan beskrives ved ligningen</p>
<p><span class="math display">\[
w_0 + w_1 \cdot x_{1} + \cdots + w_n \cdot x_{n} = 0
\]</span></p>
<p>Tabsfunktionen for kunstige neuroner giver os altså stadigvæk en plan, som kan bruges til at adskille de røde punkter fra de blå.</p>
<p>Lad os prøve først at illustrere det med datasættet bestående af de seks punkter i <a href="#fig-eks1" class="quarto-xref">figur&nbsp;1</a>. Resultat af at bruge ADALINE (fuldt optrukket linje) og en kunstig neuron (stiplet linje) ses i <a href="#fig-eks1_sigmoid" class="quarto-xref">figur&nbsp;8</a>. Det er her tydeligt, at begge metoder kan bruges til at finde en linje, som adskiller de blå punkter fra de røde, og der er i det hele taget ikke den store forskel på de to metoder.</p>
<div id="fig-eks1_sigmoid" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-eks1_sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/fig-eks1_sigmoid.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-eks1_sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;8: Fuldt optrukket linje svarer til ADALINE – stiplet linje svarer til en kunstig neuron.
</figcaption>
</figure>
</div>
<p>Bruger vi nu ADALINE og en kunstig neuron på data fra <a href="#fig-eks2" class="quarto-xref">figur&nbsp;2</a> fås resultatet i <a href="#fig-eks2_sigmoid" class="quarto-xref">figur&nbsp;9</a>. Igen svarer ADALINE til fuldt optrukket linje og sigmoid til stiplet linje. Vi kan nu se, at den kunstige neuron præcis gør det, som vi havde håbet på: Den adskiller de blå punkter fra de røde også selvom ét af punkterne er ekstremt.</p>
<div id="fig-eks2_sigmoid" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-eks2_sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/fig-eks2_sigmoid.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-eks2_sigmoid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;9: Fuldt optrukket linje svarer til ADALINE – stiplet linje svarer til en kunstig neuron.
</figcaption>
</figure>
</div>
<p>Vægtene fra den kunstige neuron i det sidste eksempel er <span class="math inline">\(w_0=-6.046\)</span>, <span class="math inline">\(w_1=-16.69\)</span> og <span class="math inline">\(w_2=10.94\)</span> svarende til linjen med ligning <span class="math display">\[
-6.046 - 16.69x_1+10.94x_2=0
\]</span> Udregner vi <span class="math display">\[
o = \sigma(-6.046 - 16.69x_1+10.94x_2)
\]</span> får vi altså sandsynligheden for at et punkt er blåt. Gør vi det fås resultatet i nedenstående tabel:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(x_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(x_2\)</span></th>
<th style="text-align: center;">Targetværdi</th>
<th style="text-align: center;">Sandsynlighed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(-0.5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1.00\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(-0.3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.90\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(-0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.7\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.96\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.03\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(-0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.10\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-0.1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.00\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.00\)</span></td>
</tr>
</tbody>
</table>
<p>Der er her fin overensstemmelse mellem targetværdien og den beregnede sandsynlighed (outputværdien <span class="math inline">\(o\)</span>). Læg også mærke til at det ekstreme punkt har en beregnet sandsynlighed på <span class="math inline">\(0.00\)</span> og dermed bliver prædikteret til klart at være et <em>ikke</em> blåt – det vil sige et rødt – punkt.</p>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/aimat\.dk");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>