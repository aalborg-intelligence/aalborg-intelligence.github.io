<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="I denne note vil vi beskrive et helt simpelt – og naivt – bud på en sprogmodel. Selvom modellen, som præsenteres her, er for simpel, giver den alligevel en god forståelse for den grundlæggende idé bag de store sprogmodeller.">

<title>Simple sprogmodeller – AI MAT - matematikken bag magien</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo/SVG/Bomaerke_05_AIMAT_2024.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-0815c480559380816a4d1ea211a47e91.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-f5808d28ca86b288a92bb47b498e84e1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Y219BCPS45"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
 
  gtag('consent', 'default', {
    'ad_storage': 'denied',
    'analytics_storage': 'denied'
  });
gtag('config', 'G-Y219BCPS45', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo/PNG/Logo_multi_AIMAT_RGB_2024.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../undervisningsforlob.html"> 
<span class="menu-text">Undervisningsforløb</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../materialer.html"> 
<span class="menu-text">Materialer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sro.html"> 
<span class="menu-text">SRO</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../srp.html"> 
<span class="menu-text">SRP</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../apps.html"> 
<span class="menu-text">Apps</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../referencer.html"> 
<span class="menu-text">Referencer</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Om os</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.youtube.com/@ai-mat"> 
<span class="menu-text"><img src="../../logo/YouTube/youtube-color-darkblue-icon.svg" style="height:2em"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Indhold</h2>
   
  <ul>
  <li><a href="#sandsynligheden-for-næste-ord" id="toc-sandsynligheden-for-næste-ord" class="nav-link active" data-scroll-target="#sandsynligheden-for-næste-ord">Sandsynligheden for næste ord</a></li>
  <li><a href="#n-gram-sprogmodeller" id="toc-n-gram-sprogmodeller" class="nav-link" data-scroll-target="#n-gram-sprogmodeller"><span class="math inline">\(N\)</span>-gram sprogmodeller</a></li>
  <li><a href="#mere-avancerede-sprogmodeller" id="toc-mere-avancerede-sprogmodeller" class="nav-link" data-scroll-target="#mere-avancerede-sprogmodeller">Mere avancerede sprogmodeller</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simple sprogmodeller</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>I denne note vil vi beskrive et helt simpelt – og naivt – bud på en sprogmodel. Selvom modellen, som præsenteres her, er for simpel, giver den alligevel en god forståelse for den grundlæggende idé bag de store sprogmodeller.</p>
<section id="sandsynligheden-for-næste-ord" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sandsynligheden-for-næste-ord">Sandsynligheden for næste ord</h2>
<p>Vi tager udgangspunkt i en sprogmodel, der skal kunne gætte næste ord i en sætning. Hvis vi for eksempel ved, at en sætning starter med</p>
<div class="llm_saetninger">
<p>"Jeg går en tur i —"</p>
</div>
<p>så skal sprogmodellen prøve at gætte det næste ord. Den skulle gerne vælge et af de mest sandsynlige næste ord. Vi skriver sandsynligheden for at næste ord er "skoven", når sætningen starter med "Jeg går en tur i", som <span class="math display">\[
P(\textrm{skoven} \mid \textrm{Jeg går en tur i}).
\]</span></p>
<p>Denne sandsynlighed kaldes for en <em>betinget sandsynlighed</em>, som du kan læse mere om i boksen herunder.</p>
<div class="callout callout-style-simple callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Betingede sandsynligheder
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Ovenfor har vi brugt notationen for betingede sandsynligheder. Hvis <span class="math inline">\(A\)</span> og <span class="math inline">\(B\)</span> er to hændelser og <span class="math inline">\(P(B)&gt;0\)</span>, så betegner <span class="math inline">\(P(A\mid B)\)</span> <em>den betingede sandsynlighed for <span class="math inline">\(A\)</span> givet <span class="math inline">\(B\)</span></em>, som er givet ved formlen <span id="eq-betinget"><span class="math display">\[
\label{eq:betinget}
P(A\mid B) = \frac{P(A\cap B)}{P(B)}
\tag{1}\]</span></span></p>
<p>Her er <span class="math inline">\(A\cap B\)</span> <em>fælleshændelsen</em>, det vil sige hændelsen, at <span class="math inline">\(A\)</span> og <span class="math inline">\(B\)</span> forekommer samtidig. Vi fortolker <span class="math inline">\(P(A\mid B)\)</span> som sandsynligheden for, at hændelsen <span class="math inline">\(A\)</span> indtræffer, hvis vi ved, at hændelsen <span class="math inline">\(B\)</span> er indtruffet. Dette giver mening i forhold til (<a href="#eq-betinget" class="quarto-xref">1</a>), idet brøken angiver, hvor stor en andel af sandsynligheden for <span class="math inline">\(B\)</span>, der udgøres af sandsynligheden for, at <span class="math inline">\(A\)</span> indtræffer samtidig med <span class="math inline">\(B\)</span>.</p>
<p>I vores eksempel ovenfor, er <span class="math inline">\(B\)</span> hændelsen, at sætningen starter med "Jeg går en tur i", mens <span class="math inline">\(A\)</span> er hændelsen, at næste ord er "skoven". Den betingede sandsynlighed <span class="math inline">\(P(A\mid B)\)</span> er så sandsynligheden for at næste ord er "skoven", når vi ved, at sætningen starter med "Jeg går en tur i". Den er givet ved <span class="math display">\[
\begin{aligned}
P(A\mid B) &amp;= P(\textrm{skoven} \mid \textrm{Jeg går en tur i}) \\
&amp;= \frac{P(\textrm{Jeg går en tur i skoven})}{P(\textrm{Jeg går en tur i})}
\end{aligned}
\]</span></p>
</div>
</div>
</div>
<p>Hvordan kan vi så finde denne sandsynlighed? Jo, her får vi brug for vores korpus af tilgængelig tekst. Vi tæller, hvor mange gange ordkombinationerne "Jeg går en tur i" og "Jeg går en tur i skoven" optræder i teksten. Vi har så, at andelen af gange, "Jeg går en tur i" efterfølges af "skoven", er givet ved</p>
<p><span class="math display">\[
\begin{multline}
P(\textrm{skoven} \mid \textrm{Jeg går en tur i})= \\ \frac{\textrm{Antal gange "Jeg går en tur i skoven" optræder}}{\textrm{Antal gange "Jeg går en tur i" optræder}}
\end{multline}
\]</span> Her opstår et problem: det er slet ikke sikkert, at kombinationen "jeg går en tur i" findes i vores tekstkorpus<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.Man er derfor nødt til at gøre noget smartere. Det kan gøres på mange måder, og vi ser først på en naiv tilgang kaldet <em><span class="math inline">\(N\)</span>-gram sprogmodeller</em>.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Selv hvis den gør, er det ikke sikkert, at alle relevante fortsættelser ("byen", "parken", "haven", ...) er repræsentereret.</p></div></div></section>
<section id="n-gram-sprogmodeller" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="n-gram-sprogmodeller"><span class="math inline">\(N\)</span>-gram sprogmodeller</h2>
<p>I <em><span class="math inline">\(N\)</span>-gram sprogmodeller</em> forsøger man også at bestemme sandsynligheden for næste ord, men nu baserer man sig kun på de <span class="math inline">\(N-1\)</span> foregående ord. Hvis vi skal gætte næste ord efter "Jeg går en tur i", ville en <span class="math inline">\(4\)</span>-gram sprogmodel basere sig på sandsynligheder på formen <span class="math display">\[
P(\textrm{skoven} \mid \textrm{en tur i})=\frac{\textrm{Antal gange "en tur i skoven" optræder}}{\textrm{Antal gange "en tur i" optræder}}
\]</span> Vi tager altså ikke starten på sætningen "Jeg går" i betragtning, fordi en 4-gram sprogmodel udelukkende kigger på de sidste tre ord "en tur i".</p>
<p>Som et eksempel på, hvordan <span class="math inline">\(N\)</span>-gram sprogmodeller fungerer, ser vi på et meget lille tekstkorpus bestående af fire sætninger med seks forskellige ord:</p>
<div class="llm_saetninger">
<p>" En hund løber efter en kat.<br>
Løber en hund efter en kat?<br>
En kat løber ikke efter en hund.<br>
Efter en kat løber en hund."</p>
</div>
<p>Der er 25 ord i teksten, men kun 6 forskellige: en (8), hund (4), løber (4), efter (4), kat (4), ikke (1), hvor tallet i parentes angiver antal gange, ordet optræder i vores tekst. Vi ignorerer tegnsætning og skelner ikke mellem små og store bogstaver.</p>
<p>Et <em>bigram</em> er et par af ord, der forekommer efter hinanden i teksten. I <a href="#tbl-hyp_bigram" class="quarto-xref">tabel&nbsp;1</a> nedenfor er der lavet en hyppighedstabel over alle bigram i vores tekst. Vi lader som om, teksten starter forfra, så det sidste "hund" efterfølges af "En".</p>
<div id="tbl-hyp_bigram" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-tbl figure page-columns page-full">
<div aria-describedby="tbl-hyp_bigram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">en</th>
<th style="text-align: center;">hund</th>
<th style="text-align: center;">løber</th>
<th style="text-align: center;">efter</th>
<th style="text-align: center;">kat</th>
<th style="text-align: center;">ikke</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>en</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>hund</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td>løber</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td>efter</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td>kat</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>ikke</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-tbl margin-caption" id="tbl-hyp_bigram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabel&nbsp;1: Hyppighed af bigram.
</figcaption>
</figure>
</div>
<p>Tabellen viser hyppigheden af forskellige bigram i vores tekst. Ordet i venstre søjle er første ord i bigrammet, og ordet i første række er andet ord i bigrammet. For eksempel betyder de to 4-taller i anden række, at "en hund" og "en kat" hver optræder 4 gange. Der forekommer 12 forskellige bigram i teksten. Det er dem, hvor der ikke står 0 i tabellen. Hvis der står 0, svarer det til et bigram, der ikke forekommer.</p>
<p>Hvis det sidste ord i vores sætning er "ord<span class="math inline">\(_1\)</span>", kan vi beregne sandsynligheden for, at næste ord vil være "ord<span class="math inline">\(_2\)</span>". Det skriver vi som <span class="math display">\[
P(\textrm{ord}_2\mid \textrm{ord}_1) = \frac{\textrm{Antal gange bigrammet "ord$_1$ ord$_2$" optræder}}{\textrm{Antal gange "ord$_1$"  optræder}}
\]</span> Hvis for eksempel det seneste ord i vores sætning er "løber", så er sandsynligheden for at næste ord er "efter" <span class="math display">\[
P(\textrm{efter} \mid \textrm{løber})=\frac{1}{4},
\]</span> idet "løber" forekommer 4 gange, og 1 af gangene er "efter" det næste ord.</p>
<p>Lad os illustrere, hvordan man kan bruge bigram til at danne nye sætninger.</p>
<ol type="1">
<li><p>Vælg et begyndelsesord - lad os sige "En".</p></li>
<li><p>Fra <a href="#tbl-hyp_bigram" class="quarto-xref">tabel&nbsp;1</a> kan vi se, at der i vores tekst er to muligheder for næste ord, nemlig "hund" og "kat". De er lige sandsynlige - de optræder begge 4 gange ud af 8. Vi slår plat og krone for at finde næste ord. Det blev "kat".</p></li>
<li><p>Vi har nu "En kat" og kigger i <a href="#tbl-hyp_bigram" class="quarto-xref">tabel&nbsp;1</a> efter et ord, der står efter "kat". Der er to muligheder: "løber" (3 gange) og "en" (1 gang). Vi vælger nu "løber" med sandsynlighed 3/4 og "en" med sandsynlighed 1/4. Det blev "løber".</p></li>
<li><p>Nu har vi "En kat løber". Hvad kommer efter "løber"? Det gør "en" (2 gange), "efter" (1 gang) og "ikke" (1 gang). Vi vælger et af ordene "en", "efter" og "ikke" med sandsynlighed hhv 2/4, 1/4 og 1/4. Vi får "en".</p></li>
<li><p>Vi har "En kat løber en". Næste mulige ord er "hund" og "kat", som er lige sandsynlige. Vi får "kat".</p></li>
<li><p>Vi slutter her og ender med sætningen "En kat løber en kat". Det giver ikke så meget mening.</p></li>
</ol>
<p>Det startede meget godt med at danne vores sætning, men på et tidspunkt holdt den op med at give mening. Problemet er, at man ikke får ret meget af sammenhængen med, når man kun bruger det sidste ord til at gætte det næste udfra. Derfor får man let genereret nogle ret underlige sætninger. Man kan forbedre det ved at kigge på <em>trigram</em>. Et trigram er en sekvens på tre ord efter hinanden. I <a href="#tbl-hyp_trigram" class="quarto-xref">tabel&nbsp;2</a> nedenfor er vist hyppigheden af trigram i vores lille tekst.</p>
<div id="tbl-hyp_trigram" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-tbl figure page-columns page-full">
<div aria-describedby="tbl-hyp_trigram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">en</th>
<th style="text-align: center;">hund</th>
<th style="text-align: center;">løber</th>
<th style="text-align: center;">efter</th>
<th style="text-align: center;">kat</th>
<th style="text-align: center;">ikke</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>en hund</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>en kat</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td>hund en</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>hund løber</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td>hund efter</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>løber en</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td>løber efter</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>løber ikke</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td>efter en</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>kat en</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td>kat løber</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td>ikke efter</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-tbl margin-caption" id="tbl-hyp_trigram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabel&nbsp;2: Hyppighed af trigram.
</figcaption>
</figure>
</div>
<p>Søjlen til venstre i <a href="#tbl-hyp_trigram" class="quarto-xref">tabel&nbsp;2</a> er de første to ord i trigrammet, mens første række angiver tredje ord. Bemærk, at kun bigram, der faktisk forekommer i vores tekstkorpus er vist i første søjle. Anden række viser således, at bigrammet "en hund" optræder med "en", "løber" og "efter" som næste ord. Trigrammet "en hund efter" optræder 2 gange i vores tekstkorpus.</p>
<p>Man kan nu finde sandsynlighederne for trigrammet "ord<span class="math inline">\(_1\)</span> ord<span class="math inline">\(_2\)</span> ord<span class="math inline">\(_3\)</span>", når vi ved, at de to første ord er "ord<span class="math inline">\(_1\)</span> ord<span class="math inline">\(_2\)</span>". Dette skriver vi igen som en betinget sandsynlighed</p>
<p><span class="math display">\[
\begin{multline}
P(\textrm{ord}_3\mid \textrm{ord}_1\textrm{ ord}_2) = \\ \frac{\textrm{Antal gange trigrammet "ord$_1$ ord$_2$ ord$_3$" optræder}}{\textrm{Antal gange bigrammet "ord$_1$ ord$_2$" optræder}}
\end{multline}
\]</span></p>
<p>Bruger man informationen i trigram til at generere ny tekst, er det mere restriktivt, hvad man kan skrive. Man kan ikke skrive "En hund en kat en hund", fordi "hund en kat" ikke er et trigram i vores tekstkorpus. Man kunne derimod godt skrive "En hund en hund en hund", da både "hund en hund" og "en hund en" er trigram i vores tekstkorpus.</p>
<ol type="1">
<li><p>Lad os begynde som i bigram-eksemplets trin 2, hvor vi har "En kat". Der er igen to muligheder: "en kat løber" og "en kat en". Lad os sige, vores tilfældige valg giver "en kat løber"</p></li>
<li><p>Nu skal vi finde en mulighed til "kat løber ..." og der kan vi vælge "en" eller "ikke". Vi kan ikke vælge "efter", som vi kunne i bigram-modellen. Vi rammer måske "En kat løber ikke"</p></li>
<li><p>Vi skal finde et ord til "løber ikke ..." og der er nu kun "efter" at vælge.</p></li>
<li><p>Vi har "en kat løber ikke efter" og har kun muligheden "ikke efter en"</p></li>
<li><p>Fra "en kat løber ikke efter en", kan vi vælge "hund" eller "kat". Vælger vi "hund", får vi "en kat løber ikke efter en hund".</p></li>
</ol>
<p>Det er et meget lille tekstkorpus, vi har, og det giver naturligvis problemer. Man kan ikke generere fornuftige sætninger som "Løber en kat efter en hund?" ("kat efter" er end ikke et bigram i vores lille tekstkorpus). Et andet problem opstår, hvis vi ønsker at starte en sætning med "Efter kat". Dette bigram forekommer ikke i vores tekstkorpus, så vi kan slet ikke komme videre.</p>
<p>Selv hvis vi havde store mængder tekst i vores tekstkorpus, er to ord ikke meget at gætte næste ord ud fra, da meningen med teksten nemt går tabt, når man kun betragter de sidste to ord. For at få et bedre indtryk af meningen med sætningen kan man bruge <em><span class="math inline">\(N\)</span>-gram</em>, som består af <span class="math inline">\(N\)</span> på hinanden følgende ord. Man prøver så at gætte det <span class="math inline">\(N\)</span>te ord ud fra de <span class="math inline">\(N-1\)</span> foregående. Her er der igen et problem med, at mange <span class="math inline">\((N-1)\)</span>-gram slet ikke findes i vores tekstkorpus. Starter vi med sådan et <span class="math inline">\((N-1)\)</span>-gram, kan vi ikke komme til at gætte videre. Jo større <span class="math inline">\(N\)</span> er, desto større bliver problemet med manglende <span class="math inline">\(N\)</span>-gram.</p>
<!-- ### EGES BØRNEBOG som eksempel - app-?? {#eges-børnebog-som-eksempel---app- .unnumbered} -->
<!-- Her kunne det være fedt med et bigram for Eges korpus Evt. en app, der -->
<!-- kan generere næste ord\... Måske opgaver baseret på børnebogen? -->
</section>
<section id="mere-avancerede-sprogmodeller" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="mere-avancerede-sprogmodeller">Mere avancerede sprogmodeller</h2>
<p>For at kunne gætte næste ord med en <span class="math inline">\(N\)</span>-gram sprogmodel, har vi brug for et stort <span class="math inline">\(N\)</span> for at få meningen med. Det giver rigtig mange mulige kombinationer af de <span class="math inline">\(N-1\)</span> ord, som vi prædikterer næste ord ud fra. Mange af dem vil ikke være repræsenteret i vores tekstkorpus, og vi kan derfor ikke benytte <span class="math inline">\(N\)</span>-gram modellen. Men hvad nu, hvis vores tekstkorpus indeholder en ordsekvens, hvis betydning minder om? Måske ønsker vi at prædiktere næste ord i sætningen</p>
<div class="llm_saetninger">
<p>"Min hund har en blød —"</p>
</div>
<p>Og måske står denne kombination af ord ikke noget sted i vores tekstkorpus. Til gengæld er der måske et sted, hvor der står</p>
<div class="llm_saetninger">
<p>"Min kat har en blød pels"</p>
</div>
<p>Hvis vi nu ved, at ordene "hund" og "kat" tit indgår i sammenhænge, der ligner hinanden, så kan vi måske erstatte sætningen "Min hund har en blød" med "Min kat har en blød" og bruge det til at gætte, at næste ord skal være "pels". For at udføre denne idé i praksis, får vi brug for en stor sprogmodel, som en model for sprogets betydning. Et eksempel på, hvordan det kan gøres, er den algoritme, som kaldes for <a href="../../materialer/sprogmodeller/word2vec.html">Word2Vec</a>. Kort fortalt er idéen at repræsentere hvert ord med en vektor, hvor ord, hvis betydning minder om hinanden, svarer til vektorer, med nogenlunde samme retning og længde. Et konkret eksempel på det ses i <a href="#fig-vektorer" class="quarto-xref">figur&nbsp;1</a>.</p>

<meta name="viewport" content="width=device-width,initial-scale=1">
<meta charset="utf-8">
<script src="https://cdn.geogebra.org/apps/deployggb.js"></script>

<!-- 
Alle geogebra filer placeres i mappen _geogebra
Erstat XXX med nr på app og erstat YYY med navn på ggb-fil -->
<script>
var parameters_vektorer = {
"id": "ggbApplet_vektorer",
"width":500,
"height":400,
"prerelease":false,
"borderColor":null,
"showMenuBar":false,
"showAlgebraInput":false,
"showToolBar":false,
"showToolBarHelp":false,
"showResetIcon":true,
"enableLabelDrags":false,
"enableShiftDragZoom":true,
"enableRightClick":false,
"errorDialogsActive":false,
"useBrowserForJS":false,
"capturingThreshold":null,
"language":"da",
// use this instead of ggbBase64 to load a .ggb file
 "filename":"_geogebra/fig_simple.ggb",
};
var applet_vektorer = new GGBApplet(parameters_vektorer, true);
</script>



<script>
window.onload = function() {
  applet_vektorer.inject('ggbApplet_vektorer');
  }
</script>

<div id="fig-vektorer" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" width="80%" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-vektorer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div id="ggbApplet_vektorer">

</div>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-vektorer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;1: Eksempel på hvordan fire ord hver bliver repræsenteret som en vektor. Vektorerne, som repræsenterer dyrerne, peger i nogenlunde samme retning sammenlignet med vektoreren, som repræsenterer ordet "kælk". Samtidig kan det også ses, at vektorerne, som repræsenterer ordene "kat" og "mis" ligner hinanden mere end vektoren, som repræsenterer ordet "hund".
</figcaption>
</figure>
</div>
<p>Når vi har lavet vektorrepræsentationer af alle ord i sproget, skal vi bruge dem til at lave prædiktioner af næste ord ud fra de foregående. Til det kan man benytte en form for <a href="../materialer/sprogmodeller/tekstgenerering.qmd">Tekstgenerering med neurale netværk</a>.I praksis bruges dog en <a href="">transformer</a>, som er endnu mere avanceret, og som i praksis er den sprogmodel, der virker bedst til tekstgenerering.</p>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/aimat\.dk");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>