<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Anbefalinger.">

<title>Associationsregler – AI MAT - matematikken bag magien</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo/SVG/Bomaerke_05_AIMAT_2024.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-c8ad9e5dbd60b7b70b38521ab19b7da4.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-117cf6564b43f3aeecf187829027ef13.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Y219BCPS45"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
 
  gtag('consent', 'default', {
    'ad_storage': 'denied',
    'analytics_storage': 'denied'
  });
gtag('config', 'G-Y219BCPS45', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo/PNG/Logo_multi_AIMAT_RGB_2024.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../undervisningsforlob/index.html"> 
<span class="menu-text">Undervisningsforløb</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../materialer/index.html"> 
<span class="menu-text">Materialer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sro/index.html"> 
<span class="menu-text">SRO</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../srp/index.html"> 
<span class="menu-text">SRP</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../apps/index.html"> 
<span class="menu-text">Apps</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../referencer/index.html"> 
<span class="menu-text">Referencer</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Om os</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.youtube.com/@ai-mat"> 
<span class="menu-text"><img src="../../logo/YouTube/youtube-color-darkblue-icon.svg" style="height:2em"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Indhold</h2>
   
  <ul>
  <li><a href="#transaktionsdata" id="toc-transaktionsdata" class="nav-link active" data-scroll-target="#transaktionsdata">Transaktionsdata</a></li>
  <li><a href="#apriori-algoritmen" id="toc-apriori-algoritmen" class="nav-link" data-scroll-target="#apriori-algoritmen">Apriori algoritmen</a></li>
  <li><a href="#associationsregler" id="toc-associationsregler" class="nav-link" data-scroll-target="#associationsregler">Associationsregler</a></li>
  <li><a href="#associationsregler-i-r" id="toc-associationsregler-i-r" class="nav-link" data-scroll-target="#associationsregler-i-r">Associationsregler i R</a></li>
  <li><a href="#opgaver" id="toc-opgaver" class="nav-link" data-scroll-target="#opgaver">Opgaver</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Associationsregler</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Denne note handler om associationsregler. Associationsregler bruges ofte i forbindelse med transaktionsdata, hvor observationer består af information om, hvilke varer kunder har købt i en forretning. Ud fra disse data vil man gerne lave en algoritme til at forudsige, hvilke varer en kunde kunne være interesseret i at købe baseret på kundens tidligere indkøb. Den slags information kan dels benyttes til at anbefale andre varer som kunden kunne være interesseret i at købe og dels til at målrette reklamer for et bestemt produkt baseret på kundernes tidligere køb.</p>
<p>Vi vil tage udgangspunkt i eksemplet med transaktionsdata, men associationsregler kan dog også benyttes i forbindelse med mange andre typer data. Det kunne fx være i forbindelse med Google’s auto-complete funktion, hvor programmet prøver at gætte hvad en bruger vil skrive baseret på de tegn der allerede er indtastet.</p>
<p>Nedenstående note er primært baseret på <span class="citation" data-cites="ESL">[@ESL]</span>, men se også <span class="citation" data-cites="top10">[@top10 Kap. 4]</span>.</p>
<section id="transaktionsdata" class="level2">
<h2 class="anchored" data-anchor-id="transaktionsdata">Transaktionsdata</h2>
<p>Betragt et datasæt over transaktioner. Det kunne fx bestå af alle handler foretaget i et online supermarked. Hver observation svarer til en kunde, mens en variabel svarer til en vare. Vi har <span class="math inline">\(p\)</span> variable, <span class="math inline">\(Z_1,\ldots, Z_p\)</span> svarende til varerne <span class="math inline">\(1,\ldots,p\)</span>. Hver variabel er en dummy-variabel af typen <span class="math display">\[
Z_j = \begin{cases}
1, &amp; \text{ kunden har købt varen,}\\
0, &amp; \text{ ellers.}
\end{cases}
\]</span></p>
<p>Vi vil gerne finde ud af hvilke varer, der typisk bliver købt sammen. Mere præcist kigger vi på en delmængde <span class="math inline">\(J\subseteq \{1,\ldots,p \}\)</span> af varerne. Sandsynligheden for at en kunde har købt alle varerne i <span class="math inline">\(J\)</span> er givet ved: <span class="math display">\[
P(J)=P\left(\bigcap_{j\in J}\{Z_j=1\}\right)= P\left(\prod_{j\in J}Z_j = 1\right).
\]</span></p>
<p>Antag at vi har et datasæt bestående af <span class="math inline">\(n\)</span> observationer <span class="math inline">\(z_{i,j}\)</span>, <span class="math inline">\(i=1,\ldots,n\)</span>, <span class="math inline">\(j=1,\ldots,p\)</span>, hvor <span class="math inline">\(z_{i,j}\)</span> altså angiver <span class="math inline">\(i\)</span>’te observation af <span class="math inline">\(Z_j\)</span>. Så kan <span class="math inline">\(P(J)\)</span> estimeres ved <span class="math display">\[
T({J}) = \frac{1}{n} \sum_{i=1}^n \prod_{j\in \mathcal{J}}z_{i,j} .}
\]</span> Dette angiver andelen af de <span class="math inline">\(n\)</span> kunder, der har købt alle varerne i <span class="math inline">\({J}\)</span>. Ofte kaldes <span class="math inline">\(T({J})\)</span> for <em>prævalensen</em> eller <em>supporten</em> af <span class="math inline">\({J}\)</span>.</p>
</section>
<section id="apriori-algoritmen" class="level2">
<h2 class="anchored" data-anchor-id="apriori-algoritmen">Apriori algoritmen</h2>
<p>Der er <span class="math inline">\(2^p\)</span> mulige delmængder af <span class="math inline">\(\{1,\ldots,p \}\)</span>. Det er derfor i praksis ikke beregningsmæssigt muligt at regne på dem alle. Idéen er derfor, at vi begrænser os til at se på de mest hyppigt forekommende delmængder. Vi søger derfor de mest almindelige varekombinationer. Mere præcist vil vi kun kigge på de varekombinationer, der forekommer med en prævalens på mindst <span class="math inline">\(t\)</span>, hvor <span class="math inline">\(t&gt;0\)</span> er en fastsat tærskelværdi. Det vil altså sige vi nøjes med at betragte <span class="math display">\[
\mathcal{S}(t)=\{{J}\subseteq \{1,\ldots,p\} \,|\, T({J})&gt;t \}.
\]</span> Hvis <span class="math inline">\(t\)</span> er stort nok, skulle antallet af delmængder vi betragter gerne være reduceret betydeligt.</p>
<p>For at finde <span class="math inline">\(\mathcal{S}(t)\)</span> kunne man vælge brute force tilgangen, hvor man går igennem alle <span class="math inline">\(2^p\)</span> delmængder og beregner prævalensen for hver. Igen kan dette være beregningsmæssigt krævende. <em>Apriori algoritmen</em> er en hurtig algoritme til at finde <span class="math inline">\(\mathcal{S}(t)\)</span>. Den finder <span class="math inline">\(\mathcal{S}(t)\)</span> uden at behøve at beregne <span class="math inline">\(T({J})\)</span> for alle <span class="math inline">\(2^p\)</span> delmængder <span class="math inline">\({J}\subseteq \{1,\ldots,p \}\)</span>.</p>
<p>Apriori algoritmen benytter følgende observation (overvej hvorfor det gælder!):</p>
<ul>
<li>Hvis <span class="math inline">\({K}\subseteq {J}\)</span> så er <span class="math inline">\(T({K})\geq T({J})\)</span>.</li>
</ul>
<p>Altså: hvis vi fjerner varer fra en varemængde <span class="math inline">\(J\)</span>, så vil prævalensen altid være større end eller lig <span class="math inline">\(T(J)\)</span>.</p>
<p>Lad <span class="math inline">\(\mathcal{S}_k(t)\)</span> betegne alle de <span class="math inline">\({J}\in \mathcal{S}(t)\)</span> som indeholder præcis <span class="math inline">\(k\)</span> elementer. Antag at <span class="math inline">\({J}\in \mathcal{S}_k(t)\)</span>. Så må <span class="math inline">\(T(J)&gt;t\)</span> pr.&nbsp;definition af <span class="math inline">\(\mathcal{S}(t)\)</span>. Hvis <span class="math inline">\(K\)</span> fremkommer ved at fjerne et element fra <span class="math inline">\(J\)</span> må også <span class="math inline">\(T(K)&gt;t\)</span> ifølge (i), og dermed må <span class="math inline">\(K\in \mathcal{S}_{k-1}(t)\)</span>. Det betyder, at <span class="math inline">\(J\)</span> må være fremkommet ved at tilføje et element til et passende valgt <span class="math inline">\(K\in \mathcal{S}_{k-1}(t)\)</span> (nemlig et <span class="math inline">\(K\)</span> med <span class="math inline">\(K\subseteq J\)</span>). Det er denne egenskab Apriori algoritmen udnytter.</p>
<p>Idéen i Apriori algoritmen er nu at konstruere <span class="math inline">\(S_{k}(t)\)</span> induktivt: Vi starter med at finde <span class="math inline">\(\mathcal{S}_1(t)\)</span>, dvs.&nbsp;alle elementer i <span class="math inline">\(\mathcal{S}(t)\)</span> bestående af præcis 1 vare. Det gør vi ved for hvert <span class="math inline">\(j=1,\ldots,p\)</span> at tjekke om prævalensen <span class="math inline">\(T(\{j\})&gt;t\)</span>. I så fald tilføjes <span class="math inline">\(\{j\}\)</span> til <span class="math inline">\(\mathcal{S}_1(t)\)</span>.</p>
<p>Antag nu, at vi har fundet <span class="math inline">\(\mathcal{S}_k(t)\)</span>. Vi har lige argumenteret for, at alle <span class="math inline">\({J}\in \mathcal{S}_{k+1}(t)\)</span> kan findes ved at tilføje et element til et <span class="math inline">\({K}\in \mathcal{S}_k(t)\)</span>. For at finde <span class="math inline">\(\mathcal{S}_{k+1}(t)\)</span> er det derfor nok at beregne <span class="math inline">\(T({J})\)</span> for alle <span class="math inline">\({J}\)</span> på formen <span class="math inline">\({K}\cup \{j\}\)</span> hvor <span class="math inline">\({K}\in  \mathcal{S}_{k}(t)\)</span> og så tilføje <span class="math inline">\({J}\)</span> til <span class="math inline">\(\mathcal{S}_{k+1}(t)\)</span> hvis <span class="math inline">\(T({J})&gt;0\)</span>. Vi slipper dermed for at beregne <span class="math inline">\(T(J)\)</span> for alle <span class="math inline">\(J\)</span> med <span class="math inline">\(+1k\)</span> elementer, da det er nok at se på <span class="math inline">\(J\)</span> på formen <span class="math inline">\(K\cup \{j\}\)</span>. Algoritmen stopper når <span class="math inline">\(\mathcal{S}_{k}(t)\)</span> er tom.</p>
<p>I pseudokodeform bliver algoritmen:</p>
<p><span class="math inline">\(\{j\}\in \mathcal{S}_1(t)\)</span> <span class="math inline">\(k \gets 1\)</span> <span class="math inline">\(K\cup\{j\}\in \mathcal{S}_{k+1}(t)\)</span> <span class="math inline">\(k \gets k+1\)</span></p>
<p><span id="ex1" data-label="ex1">[ex1]</span> Følgende datasæt indeholder observationer af fire kunder, der har købt en eller flere af varerne kage, brød, sodavand og kaffe.</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Kage</th>
<th style="text-align: center;">Brød</th>
<th style="text-align: center;">Sodavand</th>
<th style="text-align: center;">Kaffe</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Vi vil gerne finde <span class="math inline">\(\mathcal{S}(0.4)\)</span>, dvs. de varekombinationer, der forekommer hos mere end <span class="math inline">\(40\%\)</span> af kunderne, ved hjælp af Apriori algoritmen. Vi finder først <span class="math inline">\(\mathcal{S}_1(0.4)\)</span>. <span class="math display">\[
\begin{aligned}
T(\{\text{Kage}\})&amp; = \frac{3}{4}&gt;0.4.\\
T(\{\text{Brød}\}) &amp; = \frac{3}{4}&gt;0.4.\\
T(\{\text{Sodavand}\}) &amp; = \frac{1}{4}\leq 0.4\\
T(\{\text{Kaffe}\}) &amp; = \frac{1}{4}\leq 0.4.\end{aligned}
\]</span> Dermed bliver <span class="math inline">\(\mathcal{S}_1(0.4) = \{\{Kage\},\{Brød\}\}\)</span>. For at finde <span class="math inline">\(\mathcal{S}_2(0.4)\)</span> ser vi på mængder der fremkommer ved at tilføje et element til mængderne i <span class="math inline">\(\mathcal{S}_1(0.4)\)</span>. <span class="math display">\[
\begin{aligned}
T(\{\text{Kage, Brød}\})&amp; = \frac{2}{4}&gt;0.4.\\
T(\{\text{Kage, Sodavand}\})&amp; = \frac{1}{4}\leq 0.4.\\
T(\{\text{Kage, Kaffe}\})&amp; = 0\leq 0.4.\\
T(\{\text{Brød, Sodavand}\})&amp; = 0 \leq 0.4.\\
T(\{\text{Brød, Kaffe}\})&amp; = \frac{1}{4}\leq 0.4.
\end{aligned}
\]</span> Altså er <span class="math inline">\(\mathcal{S}_2(0.4)= \{\text{Kage, Brød}\}\)</span>. Bemærk at det ikke havde været nødvendigt at tjekke <span class="math inline">\(T(\{\text{Kage, Sodavand}\})\)</span>, <span class="math inline">\(T(\{\text{Kage, Kaffe}\})\)</span>, <span class="math inline">\(T(\{\text{Brød, Sodavand}\})\)</span> og <span class="math inline">\(T(\{\text{Brød, Kaffe}\})\)</span> da hverken <span class="math inline">\(\{\text{Kaffe}\}\)</span> eller <span class="math inline">\(\{\text{Sodavand}\}\)</span> var i <span class="math inline">\(\mathcal{S}_1(0.4)\)</span>. Vi finder <span class="math inline">\(\mathcal{S}_3(0.4)\)</span>: <span class="math display">\[
\begin{aligned}
T(\{\text{Kage, Brød, Sodavand}\})&amp; = 0.\\
T(\{\text{Kage, Brød, Kaffe}\})&amp; = 0.
\end{aligned}
\]</span> Altså er <span class="math inline">\(\mathcal{S}_3(0.4) =\emptyset\)</span>, og algoritmen slutter. Samlet set er <span class="math display">\[
\mathcal{S}(0.4) = \{\{\text{Kage}\},\{\text{Brød}\},\{\text{Kage, Brød}\}\}.
\]</span></p>
</section>
<section id="associationsregler" class="level2">
<h2 class="anchored" data-anchor-id="associationsregler">Associationsregler</h2>
<p>Vi vil nu gerne kunne lave udsagn af typen: hvis en kunde har købt varerne i mængden <span class="math inline">\({A}\)</span>, så er det sandsynligt at kunden også vil købe varerne i mængden <span class="math inline">\({B}\)</span>. Vi vil kun betragte varekombinationer der forekommer hyppigt, dvs. <span class="math inline">\({A}\cup {B} \in \mathcal{S}(t)\)</span> for et passende valgt <span class="math inline">\(t\)</span>. Vi antager at <span class="math inline">\({A}\)</span> og <span class="math inline">\({B}\)</span> er disjunkte. <em>Associationsreglen</em> <span class="math inline">\(A\Rightarrow B\)</span> angiver at en kunde der har købt <span class="math inline">\(A\)</span> også køber <span class="math inline">\(B\)</span>.</p>
<p>Sandsynligheden for at købe <span class="math inline">\(B\)</span> givet at man har købt <span class="math inline">\(A\)</span> er <span class="math display">\[
\label{betinget}
P({B}|{A}) = \frac{P({A}\cup {B})}{P({A})}.
\]</span> (Note: notationen er lidt uheldig her. Hændelsen <span class="math inline">\({A}\cup {B}\)</span> betyder at kunden har købt både <span class="math inline">\(A\)</span> og <span class="math inline">\(B\)</span>. Det er altså snittet mellem hændelsen at kunden har købt <span class="math inline">\(A\)</span> og hændelsen at kunden har købt <span class="math inline">\(B\)</span>.) Man kan estimere <a href="#betinget" data-reference-type="eqref" data-reference="betinget">[betinget]</a> ved <span class="math display">\[
C({A}\Rightarrow {B}) = \frac{T({A} \cup {B})}{T({A})}.
\]</span> Her står <span class="math inline">\(C\)</span>’et for <em>confidence</em>, idet <span class="math inline">\(C({A}\Rightarrow {B})\)</span> er et mål for, hvor meget vi tror på at kunder der køber <span class="math inline">\(A\)</span> også køber <span class="math inline">\(B\)</span>. Konfidensen kan fx benyttes af et online supermarked, der gerne vil give kunder der har købt varerne <span class="math inline">\(A\)</span> et forslag til hvilke varer <span class="math inline">\(B\)</span>, de også kunne være interesserede i.</p>
<p>Man kan også interessere sig for <span class="math display">\[
\label{eq:P}
\frac{P(B|A)}{P(B)},
\]</span> som angiver, hvor sandsynligt det er, at købe <span class="math inline">\(B\)</span> for kunder som har købt <span class="math inline">\(A\)</span> i forhold til hvor sandsynligt det er at købe <span class="math inline">\(B\)</span> for samtlige kunder. En værdi over 1 angiver at kunder der har købt <span class="math inline">\(A\)</span> er mere tilbøjelige til også at købe <span class="math inline">\(B\)</span> end kunder generelt. Som estimat for <a href="#eq:P" data-reference-type="eqref" data-reference="eq:P">[eq:P]</a> benyttes <span class="math display">\[
L(A\Rightarrow B) = \frac{C({A}\Rightarrow {B})}{T(B)}.
\]</span> Størrelsen <span class="math inline">\(L(A\Rightarrow B)\)</span> kaldes for <em>lift</em>. Lift-værdien kan fx benyttes af et firma, der gerne vil markedsføre <span class="math inline">\(B\)</span>. Hvis <span class="math inline">\(L(A\Rightarrow B)\)</span> er høj, er forbrugere der har købt <span class="math inline">\(A\)</span> mere tilbøjelige til at købe <span class="math inline">\(B\)</span> end flertallet. Firmaet kan defor med fordel vælge at rette sine annoncer mod forbrugere der har købt <span class="math inline">\(A\)</span>.</p>
<p>I Eksempel <a href="#ex1" data-reference-type="ref" data-reference="ex1">[ex1]</a> betagter vi associationsreglen <span class="math inline">\(\{\text{Kage}\}\Rightarrow \{\text{Brød}\}\)</span>. Vi finder konfidensen <span class="math display">\[
C(\{\text{Kage}\}\Rightarrow \{\text{Brød}\})= \frac{T(\{\text{Kage, Brød}\})}{T(\{\text{Kage}\})}=\frac{2/4}{3/4} = \frac{2}{3}
\]</span> Sandsynligheden for at en kunde der har købt kage også køber brød er altså estimeret til 2/3. Vi finder lift <span class="math display">\[
L(\{\text{Kage}\}\Rightarrow \{\text{Brød}\})= \frac{C(\{\text{Kage, Brød}\})}{T(\{\text{Brød}\})}=\frac{2/3}{3/4} = \frac{8}{9}.
\]</span> Sandsynligheden for at købe brød er altså 8/9 gange så stor når det vides at man også har købt kage. Da lift er mindre end 1, er folk der har købt kage altså mindre tilbøjelige til at købe brød end flertallet.</p>
</section>
<section id="associationsregler-i-r" class="level2">
<h2 class="anchored" data-anchor-id="associationsregler-i-r">Associationsregler i R</h2>
<p>Associationsregler for transaktionsdata kan beregnes med R-funktionen <code>apriori</code> fra pakken <code>arules</code> <span class="citation" data-cites="R">[@R]</span>.</p>
<p>Vi laver først et simpelt datasæt med tre varer. Dataformatet er en liste, hvor hvert element i listen svarer til en kundes indkøb. Alternativt kan en data frame, hvor alle søjler er binære faktorvariable, benyttes.</p>
<pre><code>indkoeb &lt;- list(
c("milk"),
c("milk","bread","cheese"),
c("milk","bread","cheese"),
c(),
c("bread")
)</code></pre>
<p>Først konverteres datasættet til et transaktionsdatasæt:</p>
<pre><code>library(arules)
indkoeb &lt;- transactions(indkoeb)</code></pre>
<p>Apriori algoritmen køres:</p>
<pre><code>rules &lt;- apriori(indkoeb)
inspect(rules)</code></pre>
<p>Det giver følgende output:</p>
<pre><code>    lhs                rhs      support confidence coverage lift     count
[1] {cheese}        =&gt; {bread}  0.4     1          0.4      1.666667 2    
[2] {cheese}        =&gt; {milk}   0.4     1          0.4      1.666667 2    
[3] {bread, cheese} =&gt; {milk}   0.4     1          0.4      1.666667 2    
[4] {cheese, milk}  =&gt; {bread}  0.4     1          0.4      1.666667 2    
[5] {bread, milk}   =&gt; {cheese} 0.4     1          0.4      2.500000 2 </code></pre>
<p>Kun associationsregler med én vare på højresiden angives. Som default vises de 10 første associationsregler med en suppport på mindst 0.1 og confidence på mindst 0.8. Dette kan ændres med optionen <code>parameter</code>:</p>
<pre><code>rules &lt;- apriori(indkoeb,parameter=list(supp = 0.2, conf = 0.5))
inspect(rules[1:3])</code></pre>
</section>
<section id="opgaver" class="level2">
<h2 class="anchored" data-anchor-id="opgaver">Opgaver</h2>
<p>Opgave (1) regnes i hånden, mens Opgave (2) regnes i R.</p>
<ul>
<li><p>Betragt et fiktivt datasæt i tabellen nedenfor:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Mælk</th>
<th style="text-align: center;">Æbler</th>
<th style="text-align: center;">Brød</th>
<th style="text-align: center;">Smør</th>
<th style="text-align: center;">Æg</th>
<th style="text-align: center;">Tandpasta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Find alle varekombinationer med prævalens (support) mindst 0.4 ved brug af Apriori algoritmen.</p></li>
<li><p>Beregn confidence og lift for alle associationsregler med support mindst 0.4 (Dvs.&nbsp;alle regler på formen <span class="math inline">\(A\Rightarrow B\)</span>, hvor <span class="math inline">\(T(A\cup B)\geq 0.4\)</span>).</p></li>
</ul></li>
<li><p>I denne opgave arbejder vi med datasættet <code>Groceries</code> fra R-pakken <code>arules</code>. Bemærk: datasættet har allerede format som et transaktionsdatasæt.</p>
<ul>
<li><p>Bestem alle associationsregler med support mindst 0.05 og konfidens mindst 0.2.</p></li>
<li><p>Hvis du skulle foreslå en anden vare til en kunde der har købt sødmælk, hvad ville du så vælge?</p></li>
<li><p>Hvis du skulle markedsføre sødmælk, hvilke kunder ville du så satse på?</p></li>
</ul></li>
</ul>
<p>99 <a href="https://www.rdocumentation.org/packages/arules/versions/1.7-5/topics/apriori">Documentation for R package arules</a> Hastie, Tibshirani, Friedman: Elements of Statistical Learning. Wu et al.: Top 10 algorithms in data mining (2008). <a href="https://link.springer.com/article/10.1007/s10115-007-0114-2">Link</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/aimat\.dk");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>