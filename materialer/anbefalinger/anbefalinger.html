<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Anbefalingssystemer">

<title>Anbefalet til dig – AI MAT - matematikken bag magien</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo/SVG/Bomaerke_05_AIMAT_2024.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-c8ad9e5dbd60b7b70b38521ab19b7da4.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-117cf6564b43f3aeecf187829027ef13.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Y219BCPS45"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
 
  gtag('consent', 'default', {
    'ad_storage': 'denied',
    'analytics_storage': 'denied'
  });
gtag('config', 'G-Y219BCPS45', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo/PNG/Logo_multi_AIMAT_RGB_2024.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../undervisningsforlob/index.html"> 
<span class="menu-text">Undervisningsforløb</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../materialer/index.html"> 
<span class="menu-text">Materialer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../srp/index.html"> 
<span class="menu-text">SRP</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../apps/index.html"> 
<span class="menu-text">Apps</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Om os</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.youtube.com/@ai-mat"> 
<span class="menu-text"><img src="../../logo/YouTube/youtube-color-darkblue-icon.svg" style="height:2em"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Indhold</h2>
   
  <ul>
  <li><a href="#en-samarbejdsbaseret-algoritme" id="toc-en-samarbejdsbaseret-algoritme" class="nav-link active" data-scroll-target="#en-samarbejdsbaseret-algoritme">En samarbejdsbaseret algoritme</a>
  <ul class="collapse">
  <li><a href="#hyppige-filmkombinationer" id="toc-hyppige-filmkombinationer" class="nav-link" data-scroll-target="#hyppige-filmkombinationer">Hyppige filmkombinationer</a></li>
  <li><a href="#andre-har-også-set" id="toc-andre-har-også-set" class="nav-link" data-scroll-target="#andre-har-også-set">Andre har også set…</a></li>
  <li><a href="#begrænsninger-ved-algoritmen" id="toc-begrænsninger-ved-algoritmen" class="nav-link" data-scroll-target="#begrænsninger-ved-algoritmen">Begrænsninger ved algoritmen</a></li>
  </ul></li>
  <li><a href="#en-indholdsbaseret-algoritme" id="toc-en-indholdsbaseret-algoritme" class="nav-link" data-scroll-target="#en-indholdsbaseret-algoritme">En indholdsbaseret algoritme</a>
  <ul class="collapse">
  <li><a href="#multipel-lineær-regression" id="toc-multipel-lineær-regression" class="nav-link" data-scroll-target="#multipel-lineær-regression">Multipel lineær regression</a>
  <ul class="collapse">
  <li><a href="#flere-variable" id="toc-flere-variable" class="nav-link" data-scroll-target="#flere-variable">Flere variable</a></li>
  </ul></li>
  <li><a href="#estimation-af-vægte" id="toc-estimation-af-vægte" class="nav-link" data-scroll-target="#estimation-af-vægte">Estimation af vægte</a></li>
  <li><a href="#mere-fleksible-modeller" id="toc-mere-fleksible-modeller" class="nav-link" data-scroll-target="#mere-fleksible-modeller">Mere fleksible modeller</a></li>
  </ul></li>
  <li><a href="#samarbejdsbaserede-modeller-for-ratings" id="toc-samarbejdsbaserede-modeller-for-ratings" class="nav-link" data-scroll-target="#samarbejdsbaserede-modeller-for-ratings">Samarbejdsbaserede modeller for ratings</a>
  <ul class="collapse">
  <li><a href="#matrixfaktorisering" id="toc-matrixfaktorisering" class="nav-link" data-scroll-target="#matrixfaktorisering">Matrixfaktorisering</a>
  <ul class="collapse">
  <li><a href="#korrektion-af-modellen" id="toc-korrektion-af-modellen" class="nav-link" data-scroll-target="#korrektion-af-modellen">Korrektion af modellen</a></li>
  </ul></li>
  <li><a href="#estimation-af-vægte-1" id="toc-estimation-af-vægte-1" class="nav-link" data-scroll-target="#estimation-af-vægte-1">Estimation af vægte</a></li>
  </ul></li>
  <li><a href="#moderne-anbefalingssystemer" id="toc-moderne-anbefalingssystemer" class="nav-link" data-scroll-target="#moderne-anbefalingssystemer">Moderne anbefalingssystemer</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Anbefalet til dig</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><img src="images/film.jpg" class="img-fluid" style="float:right;;width:40.0%"> Du kender det sikkert. Du har lige siddet og set en film på Netflix. Bagefter får du vist et forslag til en ny film, du kan se. Du har da egentlig også altid gerne villet se "Mission: Impossible", så du klikker på filmen. Efter den kommer der nye forslag. Før du får set dig om, har du siddet oppe hele natten og set film. Ikke så godt for dig, hvis du skal op og i skole næste dag, men godt for Netflix. Men hvordan ved Netflix egentlig, hvilke film der kan friste dig til at se videre? Jo, de har indsamlet data om, hvilke film du og andre brugere har set. Ved hjælp af en algoritme, et såkaldt <em>anbefalingssystem</em>, prøver den at forudsige, hvilken film du vil kunne lide.</p>
<p>Du kender anbefalingssystemer fra mange andre onlinetjenester, for eksempel YouTubes videoforslag og Spotifys personlige playlister. Sociale medier som Facebook bruger blandt andet algoritmerne til at foreslå venner og grupper. Og så kender du dem nok også fra onlinehandel. Når du har købt en vare på nettet, foreslår forretningen dig som regel en liste med andre varer, du kunne være interesseret i. Anbefalingerne er en service, der gør det nemmere at finde relevant indhold, men samtidig har de til formål at maksimere den tid, du bruger på en onlinetjeneste, eller de penge, du bruger hos en onlinebutik. Fælles for alle de bagvedliggende virksomheder er, at anbefalingssystemerne er afgørende for deres succes.</p>
<p>I denne note skal vi se på, hvordan anbefalingssystemer er lavet. Der er to overordnede typer af anbefalingssystemer:</p>
<ol type="1">
<li><em>Samarbejdsbaseret:</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Her sammenligner man brugerens adfærd med andre brugere. Algoritmen vil så anbefale noget, som brugere med samme adfærd som dig kan lide. I Netflix-eksemplet kunne algoritmen for eksempel kigge på de brugere, der har set de samme film som dig. Hvis mange af dem også har set "Mission: Impossible", tyder det på, at brugere, der ligner dig, kan lide den, og du vil derfor blive anbefalet at se den.</li>
</ol>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Engelsk: Collaborative filtering.</p></div></div><ol start="2" type="1">
<li><em>Indholdsbaseret:</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Her laver man en brugerprofil for hver bruger, der beskriver, hvilken type indhold, brugeren godt kan lide. Algoritmen kan så foreslå mere indhold af samme type. Hvis du har set mange actionfilm på Netflix, vil din brugerprofil fortælle, at du er glad for actionfilm, og algoritmen vil så foreslå actionfilmen "Mission: Impossible".</li>
</ol>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;Engelsk: Content based filtering.</p></div></div><p>Vi skal se simple eksempler på begge typer algoritmer. Der vil undervejs være links til mere avancerede algoritmer, der kan bruges til at forbedre dem. Fordi anbefalingssystemerne er så vigtige for onlinevirksomhederne, bruger de mange ressourcer på at forfine og videreudvikle algoritmerne, og de præcise algoritmer, der bruges i dag, er typisk en forretningshemmelighed!</p>
<section id="en-samarbejdsbaseret-algoritme" class="level1 page-columns page-full">
<h1>En samarbejdsbaseret algoritme</h1>
<p>Vi ser først et eksempel på, hvordan man kan lave samarbejdsbaserede anbefalinger. Vi forestiller os derfor en filmstreamingtjeneste, der gerne vil lave anbefalinger af typen "Andre har også set…". De vil altså gerne foreslå dig film, som brugere, der ligner dig, godt kan lide.</p>
<p>Lad os sige, at tjenesten har et katalog bestående af <span class="math inline">\(p\)</span> film. For hver bruger registrerer hjemmesiden, hvilke film brugeren har set. Hvis tjenesten har <span class="math inline">\(n\)</span> kunder, så indsamler den et datasæt som illustreret i <a href="#tbl-data" class="quarto-xref">tabel&nbsp;1</a>. Hver række svarer til en bruger, og hver søjle svarer til en film. Et 1-tal betyder, at brugeren har set filmen, og et 0 angiver, at brugeren ikke har set filmen.</p>
<div id="tbl-data" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-tbl figure page-columns page-full">
<div aria-describedby="tbl-data-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Brugernummer</th>
<th style="text-align: center;">“Blinkende lygter”</th>
<th style="text-align: center;">“Olsen-banden”</th>
<th style="text-align: center;">“Hævnen”</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-tbl margin-caption" id="tbl-data-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabel&nbsp;1: Eksempel på et datasæt med <span class="math inline">\(p=3\)</span> film og <span class="math inline">\(n=4\)</span> brugere. Hver række svarer til en bruger, hvor 1 angiver at brugeren har set filmen, mens 0 angiver at brugeren ikke har set filmen.
</figcaption>
</figure>
</div>
<section id="hyppige-filmkombinationer" class="level2">
<h2 class="anchored" data-anchor-id="hyppige-filmkombinationer">Hyppige filmkombinationer</h2>
<p>Som det første vil vi gerne finde ud af, hvilke film der typisk bliver set af den samme bruger. Lad os kalde filmene i tjenestens katalog for <span class="math inline">\(f_1,\ldots,f_p\)</span>. Vi kigger så på en delmængde <span class="math inline">\(J\subseteq \{f_1,\ldots,f_p \}\)</span> af filmene. Lad <span class="math inline">\(F_J\)</span> angive hændelsen, at en bruger har set alle filmene i <span class="math inline">\(J\)</span>. Sandsynligheden for, at brugeren har set alle film i <span class="math inline">\(J\)</span>, er givet ved: <span class="math display">\[
P(F_J)= P(\text{ En bruger har set alle film i } J)
\]</span></p>
<p>Vi kan estimere <span class="math inline">\(P(F_J)\)</span> ved <em>frekvensen</em> <span class="math inline">\(\hat{P}(F_{J})\)</span>, som er andelen af brugerne, der har set alle film i <span class="math inline">\(J\)</span>. <span id="eq-TA"><span class="math display">\[
\begin{aligned}
\hat{P}(F_J) &amp;= \frac{\text{Antal brugere der så alle film i } J}{\text{Samlet antal film}}\\
&amp;= \frac{\text{Antal brugere der så alle film i } J}{n}
\end{aligned}
\tag{1}\]</span></span> Populære filmkombinationer vil have høj frekvens.</p>
<div id="exm-eks1" class="theorem example">
<p><span class="theorem-title"><strong>Eksempel 1</strong></span> En streamingtjeneste viser filmene "Titanic" og "Mission: Impossible". Hvis tjenesten har 1000 brugere, hvoraf 411 har set "Titanic", 358 har set "Mission: Impossible" og 198 har set både "Titanic" og "Mission: Impossible", så er <span class="math display">\[
\begin{aligned}
&amp;\hat{P}(F_{\{\text{Titanic}\}}) = \frac{411}{1000}=0.411\\
&amp;\hat{P}(F_{\{\text{Mission: Impossible}\}}) = \frac{358}{1000}=0.358\\
&amp;\hat{P}(F_{\{\text{Titanic, Mission: Impossible}\}}) = \frac{198}{1000}=0.198
\end{aligned}
\]</span> "Titanic" var altså den mest populære af de to film, idet <span class="math inline">\(41.1\%\)</span> af brugerne havde set den, mens kun <span class="math inline">\(35.5\%\)</span> havde set "Mission: Impossible".</p>
</div>
</section>
<section id="andre-har-også-set" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="andre-har-også-set">Andre har også set…</h2>
<p>Streamingtjenesten har registreret, at du har set alle filmene i mængden <span class="math inline">\(I\)</span>. De vil nu gerne kunne udtale sig om, hvor sandsynligt det er, at du også vil se filmene i mængden <span class="math inline">\(J\)</span>. Vi antager, at mængderne <span class="math inline">\({I}\)</span> og <span class="math inline">\({J}\)</span> er disjunkte, altså at de ikke har nogen film tilfælles. Sandsynligheden for at se alle filmene i <span class="math inline">\(J\)</span>, givet at man har set alle filmene i <span class="math inline">\(I\)</span>, kan beskrives ved en <em>betinget sandsynlighed</em>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> <span class="math display">\[
P(F_{J}\mid F_{I}) = \frac{P(F_{I}\cap F_{J})}{P(F_{I})}
\]</span> Fælleshændelsen <span class="math inline">\(F_I \cap F_J\)</span> er hændelsen, at man har set alle filmene i <span class="math inline">\(I\)</span> og alle filmene <span class="math inline">\(J\)</span>. Det vil sige, at man har set alle filmene i <span class="math inline">\(I\cup J\)</span>. Derfor er <span class="math inline">\(F_{I}\cap F_{J} = F_{I\cup J}\)</span> og dermed <span id="eq-betinget"><span class="math display">\[
\frac{P(F_{J}\cap F_{I})}{P(F_{I})}=\frac{P(F_{I\cup J} )}{P(F_{I})}
\tag{2}\]</span></span></p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;Hvis du har brug for at genopfriske betingede sandsynligheder, kan du læse mere i boksen nedenfor.</p></div></div><p>Vi kan altså estimere sandsynligheden for, at en bruger, der har set alle film i <span class="math inline">\(I\)</span>, også har set alle film i <span class="math inline">\(J\)</span>, ved andelen af de brugere, der har set alle filmene i <span class="math inline">\(I\)</span>, der har set alle filmene i både <span class="math inline">\(I\)</span> og <span class="math inline">\(J\)</span>.</p>
<p>Streamingtjenesten kan bruge disse betingede sandsynligheder til at foreslå nye film. Hvis de har registreret, at du har set alle film i <span class="math inline">\(I\)</span>, vil de foreslå en ny liste af film <span class="math inline">\(J\)</span>, hvor <span class="math inline">\(\hat{P}(F_J \mid F_I)\)</span> er høj.</p>
<p>Man kan estimere sandsynligheden (<a href="#eq-betinget" class="quarto-xref">2</a>) ved at indsætte estimaterne for tæller og nævner fra (<a href="#eq-TA" class="quarto-xref">1</a>). Det giver <span id="eq-C"><span class="math display">\[
\hat{P}(F_J\mid F_I) = \frac{\hat{P}(F_{{I} \cup {J}})}{\hat{P}(F_{I})}.
\tag{3}\]</span></span> I beregninger er det nyttigt at vide at <span class="math display">\[
\begin{aligned}
\hat{P}(F_J \mid F_I) &amp;= \frac{\hat{P}(F_{I\cup J})}{\hat{P}(F_{I})}\\
&amp;=\frac{\frac{\text{Antal der har set alle film i } I\cup J}{n}}{\frac{\text{Antal der har set alle film i } I }{n}}\\
&amp;=\frac{\text{Antal der har set alle film i } I \cup J}{\text{Antal der har set alle film i } I}
\end{aligned}
\]</span></p>
<div class="callout callout-style-simple callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Betinget sandsynlighed
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Lad <span class="math inline">\(A\)</span> og <span class="math inline">\(B\)</span> være to hændelser, således at <span class="math inline">\(B\)</span> har positiv sandsynlighed <span class="math inline">\(P(B)&gt;0\)</span>. <em>Den betingede sandsynlighed for</em> <span class="math inline">\(A\)</span> givet <span class="math inline">\(B\)</span> betegnes <span class="math inline">\(P(A|B)\)</span> og er defineret som</p>
<p><span class="math display">\[
P(A\mid B) = \frac{P(A\cap B)}{P(B)}.
\]</span></p>
<p>Her er <span class="math inline">\(A\cap B\)</span> <em>fælleshændelsen</em>, det vil sige hændelsen, at <span class="math inline">\(A\)</span> og <span class="math inline">\(B\)</span> forekommer samtidig. Vi fortolker <span class="math inline">\(P(A\mid B)\)</span> som sandsynligheden for, at hændelsen <span class="math inline">\(A\)</span> indtræffer, hvis vi ved, at hændelsen <span class="math inline">\(B\)</span> er indtruffet. Dette giver mening i forhold til definitionen, idet brøken angiver, hvor stor en andel af sandsynligheden for <span class="math inline">\(B\)</span>, der udgøres af sandsynligheden for, at <span class="math inline">\(A\)</span> indtræffer samtidig med <span class="math inline">\(B\)</span>.</p>
<p>Lad os se på et eksempel, hvor vi slår to gange med en terning. Lad <span class="math inline">\(A\)</span> være hændelsen, at vi slår to seksere, og lad <span class="math inline">\(B\)</span> hændelsen, at den første terning viser seks. Da der er 36 mulige kombinaioner af, hvad de to terninger kan vise, er</p>
<p><span class="math display">\[
P(A)=P(\textrm{to 6'ere})=1/36
\]</span> og <span class="math display">\[
P(B)=P(\textrm{første terning viser 6})=1/6.
\]</span> Intuitivt vil man forvente, at sandsynligheden for to seksere vokser, hvis den første terning viser en sekser. Det kan vi bekræfte ved hjælp at betingede sandsynligheder. <span class="math display">\[
P(\textrm{to 6'ere} \mid \textrm{første terning viser 6}) = P(A\mid B) =  \frac{P(A\cap B)}{P(B)} = \frac{1/36}{1/6} = \frac{1}{6}.
\]</span></p>
<p>Her har vi udnyttet, at <span class="math inline">\(A\cap B=A\)</span>, da første terning er nødt til at vise seks for, at vi kan få to seksere. Vi ser altså, at <span class="math display">\[
P(\textrm{to 6'ere} \mid \textrm{første terning viser 6}) = \frac{1}{6} \neq \frac{1}{36} = P(\textrm{to 6'ere}).
\]</span></p>
<p>Terningeksemplet viser et eksempel, hvor <span class="math inline">\(P(A)\neq P(A\mid B)\)</span>, altså hvor sandsynligheden for <span class="math inline">\(A\)</span> ændrer sig, hvis vi ved, at <span class="math inline">\(B\)</span> er indtruffet. Dette er ofte tilfældet. Nogle gange kan vi dog have at <span class="math inline">\(P(A\mid B)=P(A)\)</span>, altså at vi ikke får nogen ny viden om sandsynligheden for <span class="math inline">\(A\)</span> ud fra vores viden om <span class="math inline">\(B.\)</span> I dette tilfælde siger vi, at <span class="math inline">\(A\)</span> og <span class="math inline">\(B\)</span> er <em>stokastisk uafhængige</em>.</p>
</div>
</div>
</div>
<div id="exm-eks2" class="theorem example">
<p><span class="theorem-title"><strong>Eksempel 2</strong></span> Vi ser igen på filmtjenesten fra <a href="#exm-eks1" class="quarto-xref">eksempel&nbsp;1</a>. En bruger har lige set "Titanic", og filmtjenesten vil nu gerne anbefale en ny film. Vi ser derfor på sandsynligheden for, at en bruger, der har set "Titanic", også har set "Mission: Impossible". Vi finder <span class="math display">\[\hat{P}(F_{\text{Mission: Impossible}} \mid F_{\text{ Titanic }} ) = \frac{198}{411} \approx 0.482\]</span> Det er altså cirka 48,2% af de brugere, der har set "Titanic", der også har set "Mission: Impossible". Hvis der er 145 brugere, der både har set "Titanic" og "Jurassic Park", så er <span class="math display">\[\hat{P}(F_{\text{ Jurassic Park}} \mid F_{\text{ Titanic }}) = \frac{145}{411} \approx 0.353 \]</span> Folk, der har set "Titanic", er således mere tilbøjelige til at se "Mission: Impossible" end "Jurassic Park". "Mission: Impossible" vil derfor være den bedste anbefaling.</p>
</div>
</section>
<section id="begrænsninger-ved-algoritmen" class="level2">
<h2 class="anchored" data-anchor-id="begrænsninger-ved-algoritmen">Begrænsninger ved algoritmen</h2>
<p>Vi har beskrevet en simpel og klassisk måde at lave anbefalinger på, og er særligt relevant for onlineforretninger, der vil lave forslag af typen "Andre har også købt". Selv for en lille virksomhed er det nemt at indsamle det relevante data og bruge algoritmen til at lave nye forslag.</p>
<p>Der er dog også forskellige begrænsninger ved tilgangen ovenfor. Måske er der ingen brugere, der har set præcis de samme film som dig. I så fald har vi ikke nogen at sammenligne med. At man har set en film betyder jo heller ikke nødvendigvis, at man kunne lide den.</p>
<p>Moderne internetvirksomheder har mulighed for at indsamle meget mere data, som kan bruges til at forbedre anbefalingerne. Netflix indsamler for eksempel data om:</p>
<ul>
<li><p>Filmene: For eksempel genre, sprog, instruktør, skuespillere, antal Oscars.</p></li>
<li><p>Brugeren: Ofte angiver man enkelte peronoplysninger, så som emailadresse og sprog, når man opretter en profil, men mange har ikke lyst til direkte at afgive for mange oplysninger om sig selv. I stedet prøver tjenesten at opnå disse oplysninger indirekte, ved at indsamle data om brugerens adfærd på deres hjemmeside.</p></li>
<li><p>Brugerens adfærd: Hvilke film har brugeren set, blev filmen set til ende, hvilken rating fik den efterfølgende, på hvilken tid af dagen blev filmen set og fra hvilket device, og hvilke film har brugeren ellers søgt på.</p></li>
</ul>
<p>For at tage alle disse oplysninger i betragtning, får man brug for meget mere komplicerede algoritmer.</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opgave 1: Online elektronikbutik
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>En online elektronikbutik har 1.000.000 kunder. Heraf har 235.476 købt en computer, 423.517 har købt en mus og 114.237 købt et tastatur, 23.127 har kørt både computer og mus, mens 51.633 har kørt både computer og tastatur.</p>
<ul>
<li><p>Beregn frekvensen af <span class="math inline">\(F_{\{\text{computer}\}}\)</span>, <span class="math inline">\(F_{\{\text{mus}\}}\)</span>, <span class="math inline">\(F_{\{\text{tastatur}\}}\)</span>, <span class="math inline">\(F_{\{\text{computer,mus}\}}\)</span> og <span class="math inline">\(F_{\{\text{computer, tastatur}\}}\)</span>. Hvilken vare var mest populær?</p></li>
<li><p>Beregn <span class="math inline">\(\hat{P}( F_{\text{mus}} \mid F_{\text{computer}})\)</span> og <span class="math inline">\(\hat{P}(F_{\text{tastatur}} \mid F_{\text{computer}} )\)</span>. Hvilken vare ville du anbefale til en bruger, der lige har købt en computer?</p></li>
</ul>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opgave 2: Film
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Se på datasættet i <a href="#tbl-data" class="quarto-xref">tabel&nbsp;1</a>.</p>
<ul>
<li><p>Beregn frekvenserne af <span class="math inline">\(F_{\{\text{Blinkende Lygter}\}}\)</span>, <span class="math inline">\(F_{\{\text{Olsen-banden}\}}\)</span> og <span class="math inline">\(F_{\{\text{Blinkende Lygter, Olsen-banden}\}}\)</span>.</p></li>
<li><p>Beregn <span class="math inline">\(\hat{P}(F_{\text{Olsen-banden}}\mid F_{\text{Blinkende lygter}} )\)</span> og <span class="math inline">\(\hat{P}( F_{\text{Hævnen}}\mid F_{\text{Blinkende lygter}})\)</span>. Hvilken film ville du foreslå en bruger, der lige har set “Blinkende lygter”?</p></li>
</ul>
</div>
</div>
</div>
</section>
</section>
<section id="en-indholdsbaseret-algoritme" class="level1 page-columns page-full">
<h1>En indholdsbaseret algoritme</h1>
<p>En af de ting, Netflix gør for at få flere oplysninger om din filmsmag, er, at de beder dig rate de film, du har set. I dag sker det med likes, men tidligere brugte de ratings fra 1 til 5. I det følgende antager vi, at alle ratings er på en skala fra 1 til 5, hvor 5 er bedst. Netflix bruger dine ratings til at prøve at gætte, hvordan du ville rate deres øvrige film. De kan så foreslå en film, som de tror, du vil rate højt.</p>
<p>I dette afsnit skal vi se på en indholdsbaseret tilgang til at forudsige, eller <em>prædiktere</em>, ratings. Idéen er, at dine ratings formodes at afhænge dels af egenskaber ved filmen, kaldet <em>features</em>, og dels af dine egne præferencer, det vil sige, hvor positivt eller negativt du vurderer forskellige features.</p>
<section id="multipel-lineær-regression" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="multipel-lineær-regression">Multipel lineær regression</h2>
<p>Som eksempel kan vi kigge på to features. Den første er, hvor mange procent af filmen, der udgøres af kærlighedsscener. Den kalder vi <span class="math inline">\(x_1\)</span>. Den anden er, hvor mange procent af filmen, der udgøres af actionscener. Den kalder vi <span class="math inline">\(x_2\)</span>. Begge features måles på en skala fra 0 til 100 procent.</p>
<p>Vi forstiller os så, at en given brugers ratings er på formen <span id="eq-multipel2"><span class="math display">\[ r=b + p_1x_1 + p_2x_2  \tag{4}\]</span></span> Hvis der hverken er kærlighed eller action i filmen, det vil sige hvis <span class="math inline">\(x_1=x_2=0\)</span>, så er <span class="math display">\[r= b + p_1\cdot 0 + p_2\cdot 0 = b\]</span> Vi kan altså fortolke <span class="math inline">\(b\)</span> som brugerens rating af en film, der hverken indeholder kærlighed eller action. Dette minder om skæringen i en lineær regressionsmodel, og vi vil derfor omtale <span class="math inline">\(b\)</span> som <em>skæringen</em>.</p>
<p>Vi ser også, at hvis andelen af kærlighedsscener <span class="math inline">\(x_1\)</span> stiger med 1 procentpoint til <span class="math inline">\(x_1+1\)</span>, og <span class="math inline">\(x_2\)</span> fastholdes, så stiger ratingen fra <span class="math display">\[r= b+p_1x_1 + p_2x_2\]</span> til <span class="math display">\[r=b+p_1(x_1+1) + p_2x_2 = b+p_1x_1 + p_2x_2 +p_1\]</span> Vi ser, at når <span class="math inline">\(x_1\)</span> vokser med 1 enhed, så vokser ratingen med <span class="math inline">\(p_1\)</span> (hvis altså <span class="math inline">\(x_2\)</span> samtidig fastholdes). Dette minder om fortolkningen af hældningskoefficienten i en lineær regressionsmodel. Man kan derfor tænke på <span class="math inline">\(p_1\)</span> som hældningen for <span class="math inline">\(x_1\)</span>. På samme vis kan man argumentere for, at hvis <span class="math inline">\(x_1\)</span> fastholdes, mens <span class="math inline">\(x_2\)</span> vokser med 1 enhed, så stiger ratingen med <span class="math inline">\(p_2\)</span>. Vi kan altså opfatte <span class="math inline">\(p_2\)</span> som en hældningskoefficient for <span class="math inline">\(x_2\)</span>.</p>
<p>Fortegnet for <span class="math inline">\(p_2\)</span> afslører, om brugeren vurderer action positivt eller negativt. Hvis <span class="math inline">\(p_2\)</span> er positiv, stiger ratingen, jo mere action der er i filmen. Jo større <span class="math inline">\(p_2\)</span> er, desto mere begejsret er brugeren for action. Hvis <span class="math inline">\(p_2\)</span> er negativ, falder ratingen, jo mere action der er i filmen. Tilsvarende fortæller <span class="math inline">\(p_1\)</span> noget om, hvor glad brugeren er for kærlighedsfilm. Vi kan derfor fortolke <span class="math inline">\(p_1\)</span> og <span class="math inline">\(p_2\)</span> som mål for brugerens præferencer.</p>
<p>Modellen i (<a href="#eq-multipel2" class="quarto-xref">4</a>) har mange ligheder med den lineære regressionsmodel, blot er der to variable <span class="math inline">\(x_1\)</span> og <span class="math inline">\(x_2\)</span> i stedet for en enkelt <span class="math inline">\(x\)</span>-variabel. Den kaldes derfor for den <em>multiple lineære regressionsmodel</em>. Der indgår tre konstanter, nemlig <span class="math inline">\(b\)</span>, <span class="math inline">\(p_1\)</span> og <span class="math inline">\(p_2\)</span>, som vi kalder for <em>vægte</em>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> Disse vægte er specifikke for den enkelte bruger. Der skal altså laves en multipel lineær regressionsmodel for hver enkelt bruger.</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;Nogle gange kaldes de også for <em>parametre</em>.</p></div></div><p>Når vi har lavet en multipel lineær regressionsmodel for en bruger, kan vi bruge den til at prædiktere ratings. For hver film kan vi indsætte dens features i modellen og beregne brugerens forventede rating af filmen. Algoritmen kan så anbefale den film, som brugeren forventes at rate bedst.</p>
<p>SKAL DER EVT LAVES NOGET VISUALISERING?</p>
<div id="exm-eks3" class="theorem example">
<p><span class="theorem-title"><strong>Eksempel 3</strong></span> En bruger, der foretrækker actionfilm vil måske have <span class="math inline">\(b=2\)</span>, <span class="math inline">\(p_1=-0.02\)</span> og <span class="math inline">\(p_2=0.05\)</span>. Så er brugerens ratings givet ved <span class="math display">\[r= 2 - 0.02x_1 + 0.05x_2\]</span> En romantisk film har måske <span class="math inline">\(x_1=50\)</span> og <span class="math inline">\(x_2=0\)</span>. Brugeren ville så give filmen ratingen <span class="math display">\[r=2-0.02\cdot 50+0.05\cdot 0=1\]</span> En actionfilm ville måske have <span class="math inline">\(x_1=5\)</span> og <span class="math inline">\(x_2=40\)</span>. Det ville give ratingen <span class="math display">\[r=2-0.02\cdot 5 + 0.05\cdot 40 = 3.9 \]</span></p>
</div>
<section id="flere-variable" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="flere-variable">Flere variable</h3>
<p>Mere generelt kunne man vælge at betragte <span class="math inline">\(M\)</span> features. Vi ville så have <span class="math inline">\(M\)</span> variable <span class="math inline">\(x_1,\ldots, x_M\)</span>. For hver bruger ville vi have så have <span class="math inline">\(M\)</span> vægte <span class="math inline">\(p_1,\ldots,p_M\)</span>, der beskriver brugerens præferencer, og en skæring <span class="math inline">\(b\)</span>. Vi modellerer brugerens rating af en film som <span id="eq-multipel"><span class="math display">\[{r} = b+ p_{1}x_{1} + p_{2}x_{2} + \dotsm + p_{M}x_{M} \tag{5}\]</span></span> Dette kaldes en multipel lineær regressionsmodel med <span class="math inline">\(M\)</span> variable.</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opgave 3: Ratings af film
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Vi betragter 3 features, nemlig varighed, produktionsår (regnet i forhold til år 2000), og vurdering på IMDb. Tre film har følgende features:</p>
<div id="tbl-ratingopgave" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure" aria-labelledby="tbl-ratingopgave-caption">
<div aria-describedby="tbl-ratingopgave-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 5%">
<col style="width: 27%">
<col style="width: 15%">
<col style="width: 36%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">"Titanic"</th>
<th style="text-align: center;">"Olsen-banden ser rødt"</th>
<th style="text-align: center;">"Jagten"</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x_1\)</span></td>
<td style="text-align: center;">Varighed</td>
<td style="text-align: center;">194</td>
<td style="text-align: center;">105</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(x_2\)</span></td>
<td style="text-align: center;">År - 2000</td>
<td style="text-align: center;">-3</td>
<td style="text-align: center;">-24</td>
<td style="text-align: center;">12</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x_3\)</span></td>
<td style="text-align: center;">IMdb rating</td>
<td style="text-align: center;">7.9</td>
<td style="text-align: center;">7.7</td>
<td style="text-align: center;">8.3</td>
</tr>
</tbody>
</table>
</div>

</figure>
</div>
<ul>
<li><p>En bruger, som foretrækker gamle film, men hader lange film, har vægtene <span class="math inline">\(p_1=-0.01\)</span>, <span class="math inline">\(p_2=-0.1\)</span> og <span class="math inline">\(p_3= 0.1\)</span> samt <span class="math inline">\(b=2.8\)</span>. Prædiktér brugerens ratings af de tre film. Hvilken film ville du anbefale brugeren?</p></li>
<li><p>En anden bruger foretrækker film af god kvalitet, men går ikke op i varighed og alder. Vedkommende har derfor præferencerne <span class="math inline">\(b=-1\)</span>, <span class="math inline">\(p_1=0\)</span>, <span class="math inline">\(p_2=0\)</span>, <span class="math inline">\(p_3=0.6\)</span>. Prædiktér brugerens ratings og anbefal en film.</p></li>
</ul>
</div>
</div>
</div>
<div id="tbl-ratingopgave-caption" class="margin-figure-caption column-margin callout-4-contents callout-collapse collapse show callout-margin-content callout-margin-content-simple">
Tabel&nbsp;2
</div><div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opgave 4: Multipel regressionsmodel med én variabel
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<ul>
<li>Gør rede for, at en multipel regressionsmodel med én variabel, er det samme som en almindelig regressionsmodel, som I kender det fra gymnasieundervisningen.</li>
</ul>
</div>
</div>
</div>
</section>
</section>
<section id="estimation-af-vægte" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="estimation-af-vægte">Estimation af vægte</h2>
<p>Vi vil altså gerne have lavet en multipel lineær regressionsmodel for en bruger. I det følgende ser vi bare på en model med to features som i (<a href="#eq-multipel2" class="quarto-xref">4</a>). Men hvor får vi brugerens præferencevægte <span class="math inline">\(b,p_{1},p_{2}\)</span> fra? Svaret er, at det vil vi få en computer til at <em>lære</em> ud fra data, som streamingtjenesten har indsamlet om brugerens tildligere ratings af film.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> Et eksempel på sådan et datasæt kan ses i <a href="#tbl-ratings" class="quarto-xref">tabel&nbsp;3</a>. Bemærk, at datasættet kun indeholder de film, som brugeren faktisk har set og tildelt en rating.</p>
<div class="no-row-height column-margin column-container"><div id="fn5"><p><sup>5</sup>&nbsp;At lære en computer at lave prædiktioner ud fra et datasæt kaldes <em>maskinlæring</em>, eller på engelsk <em>machine learning</em>, og er et centralt element i de fleste former for kunstig intelligens.</p></div></div><div id="tbl-ratings" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-tbl figure page-columns page-full">
<div aria-describedby="tbl-ratings-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(x_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(x_2\)</span></th>
<th style="text-align: center;">Rating</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Film 1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">Film 2</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Film 3</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">Film 4</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-tbl margin-caption" id="tbl-ratings-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabel&nbsp;3: Eksempel på datasæt over en brugers rating af fire film og filmenes features.
</figcaption>
</figure>
</div>
<p>Vi betegner ratingen af <span class="math inline">\(j\)</span>te film med <span class="math inline">\(r_j\)</span> og dens to features med <span class="math inline">\(x_{1j}\)</span> og <span class="math inline">\(x_{2j}\)</span>. Vores model prædikterer så brugerens rating af den <span class="math inline">\(j\)</span>te film ved</p>
<p><span id="eq-model"><span class="math display">\[
\hat{r}_{j} = p_{1}x_{1j} + p_{2}x_{2j}
\tag{6}\]</span></span></p>
<p>Hvis modellen er god, skulle den prædikterede rating <span class="math inline">\(\hat{r}_j\)</span> gerne ligge tæt på den faktiske rating <span class="math inline">\(r_j\)</span>. Vi vil derfor gerne have, at prædiktionsfejlen <span class="math inline">\(r_{j}-\hat{r}_{j}\)</span> er tæt på 0. Da både positive og negative værdier langt fra <span class="math inline">\(0\)</span> er problematiske, vælger vi at kvadrere, så vi slipper af med fortegnene. Vi vil så gerne have, at den kvadrerede prædiktionsfejl <span class="math inline">\((r_{j}-\hat{r}_{j})^2\)</span> er så lav som muligt. Det skal gælde for hver eneste film i vores datasæt. Vi kræver derfor, at summen af alle de kvadrerede prædiktionsfejl for alle filmene skal være lav. Denne sum er givet ved <span class="math display">\[E= (r_{1}-\hat{r}_{1})^2 + (r_{2}-\hat{r}_{2})^2 + \dotsm + (r_N-\hat{r}_N)^2  \]</span> Her er <span class="math inline">\(N\)</span> antallet af film, som brugeren har ratet.</p>
<p>Størrelsen <span class="math inline">\(E\)</span> kaldes en <em>tabsfunktion</em>. Hvis modellen er god, skal tabsfunktionen altså være så lille som muligt. Tabsfunktionen afhænger af, hvordan vi har valgt vægtene <span class="math inline">\(b\)</span>, <span class="math inline">\(p_1\)</span> og <span class="math inline">\(p_2\)</span>. Man kan altså betragte <span class="math inline">\(E\)</span> som en funktion af vægtene. Vi ønsker at finde de vægte, der minimerer tabsfunktionen, svarende til at vores prædikterede ratings kommer så tæt på de faktiske ratings som muligt.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;Hvis du har hørt om mindste kvadraters metode i forbindelse med lineær regression, så er det samme princip, der bruges her.</p></div><div id="fn7"><p><sup>7</sup>&nbsp;Hvis du ikke kender til partielle afledte, eller du har brug for en genopfriskning, kan du læse om det i noten om <a href="../../materialer/funktioner_af_flere_variable/funktioner_af_flere_variable.html">Funktioner af flere variable</a>.</p></div></div><p>Hvordan finder man minimum for en funktion, der afhænger af flere variable? Hvis der kun er én variabel, ved du, at man kan differentiere funktionen og lede efter minimum i de punkter, hvor den afledte er nul. Noget tilsvarende gør sig gældende, når der er flere variable. Her er det bare de partielle afledte<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, der alle er nul i et minimumspunkt. KUNNE MAN SKRIVE NOGET OM DET I NOTEN OM PARTIELLE AFLEDTE? I vores tilfælde søger vi altså værdier af <span class="math inline">\(b\)</span>, <span class="math inline">\(p_1\)</span> og <span class="math inline">\(p_2\)</span>, så <span class="math display">\[
\begin{aligned}
\frac{\partial E}{\partial p_1} = 0\\ \\
\frac{\partial E}{\partial p_2} = 0\\ \\
\frac{\partial E}{\partial b} = 0
\end{aligned}
\]</span> I opgaven nedenfor bliver du bedt om at beregne de partielle afledte af <span class="math inline">\(E\)</span>. Det fører til <span id="eq-partiel"><span class="math display">\[
\begin{aligned}
&amp;\frac{\partial E}{\partial p_1} = -2x_{11}(r_1-\hat{r}_1)- \dotsm -2x_{1N}(r_N-\hat{r}_N)\\ \\
&amp;\frac{\partial E}{\partial p_2} = -2x_{21}(r_1-\hat{r}_1) - \dotsm -2x_{2N}(r_N-\hat{r}_N) \\ \\
&amp;\frac{\partial E}{\partial b} = - 2(r_1-\hat{r}_1) - \dotsm  - 2(r_N-\hat{r}_N)
\end{aligned}
\tag{7}\]</span></span> For at finde minimumspunktet, skal vi altså løse ligningerne <span class="math display">\[
\begin{aligned}
&amp;\frac{\partial E}{\partial p_1} = -2x_{11}(r_1-\hat{r}_1)- \dotsm -2x_{1N}(r_N-\hat{r}_N)=0\\
&amp;\frac{\partial E}{\partial p_2} = -2x_{21}(r_1-\hat{r}_1) - \dotsm -2x_{2N}(r_N-\hat{r}_N)=0 \\
&amp;\frac{\partial E}{\partial b} = - 2(r_1-\hat{r}_1) - \dotsm  - 2(r_N-\hat{r}_N)=0
\end{aligned}
\]</span> Det viser sig, at disse ligninger kan løses eksplicit og give en formel for estimaterne for <span class="math inline">\(b\)</span>, <span class="math inline">\(p_1\)</span> og <span class="math inline">\(p_2\)</span>. Det vil vi dog ikke gøre her.</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opgave 5: Partielle afledede
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<ul>
<li><p>Vis, at de partielle afledte er som givet i (<a href="#eq-partiel" class="quarto-xref">7</a>). Bemærk, at da <span class="math inline">\(E\)</span> er en sum, kan den differentieres ledvist. Det er altså nok at vise, at <span class="math display">\[
\begin{aligned}
&amp;\frac{\partial (r_j-\hat{r}_j)^2}{\partial p_1} = -2x_{1j}(r_j-\hat{r}_j)\\
&amp;\frac{\partial (r_j-\hat{r}_j)^2}{\partial p_2} = -2x_{2j}(r_j-\hat{r}_j)  \\
&amp;\frac{\partial (r_j-\hat{r}_j)^2}{\partial b} = - 2(r_j-\hat{r}_j)
\end{aligned}
\]</span></p></li>
<li><p>Her burde de sagtens selv kunne lave noget i Excel…</p></li>
</ul>
</div>
</div>
</div>
</section>
<section id="mere-fleksible-modeller" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="mere-fleksible-modeller">Mere fleksible modeller</h2>
<p>Multiple lineære regressionsmodeller er meget populære. En af grundene er, at de er simple og nemme at fortolke. Det kan være godt for Netflix med en model, der er nem at fortolke, hvis de for eksempel gerne vil lave markedsanalyser for at finde ud af, hvilke film, der hitter blandt brugerne. Men for at lave anbefalinger af film, har vi egentlig ikke brug for at forstå, hvor anbefalingen kommer fra, bare den virker. Der er altså ikke noget i vejen for at bruge en mere kompliceret model.</p>
<p>I mange sammenhænge tilpasser multiple lineære regressionsmodeller virkeligheden godt, men nogle gange er virkeligheden ikke lineær. For eksempel er der sikkert mange, der vil mene, at lidt action gør filmen mere spændende, men at der også skal være anden handling, for at filmen er interessant. De vil således give bedst ratings til film med et moderat indhold af action. En funktion med en <span class="math inline">\(\cap\)</span>-formet graf ville give en bedre model. Dette er illustreret i <a href="#fig-ikke-lineare" class="quarto-xref">figur&nbsp;1</a>.</p>
<div id="fig-ikke-lineare" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-ikke-lineare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/ikke_lineare.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-ikke-lineare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;1: En ikke lineær sammenhæng mellem rating og graden af action.
</figcaption>
</figure>
</div>
<p>En mulighed kunne være at bruge et andengradspolynomium. Du kan læse mere om polynomiel regression i noten om <a href="../../materialer/krydsvalidering/krydsvalidering.html#polynomiel-regression">Krydsvalidering</a>.</p>
<p>Et andet problem opstår, hvis en film har meget ekstreme features. Så ryger dens prædikterede ratings nemt uden for intervallet 1 til 5. En funktion, hvis graf flader ud for meget store eller små featureværdier, ville være mere passende i dette tilfælde. Dette er illustreret i <a href="#fig-flader_ud" class="quarto-xref">figur&nbsp;2</a>.</p>
<div id="fig-flader_ud" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-flader_ud-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/flader_ud.png" class="img-fluid figure-img" style="width:75.0%">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-flader_ud-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figur&nbsp;2: En graf som flader ud for både små og store værdier af en feature.
</figcaption>
</figure>
</div>
<p>En af de vigtigste algoritmer inden for kunstig intelligens er de såkaldte <em>neurale netværk</em>. Neurale netværk giver mulighed for at prædiktere ratings som en ikke-lineær funktion af filmens features. De kan modellere en stor klasse af forskellige funktioner. Prisen for det er dog, at vi ikke får et pænt funktionsudtryk, som er nemt at fortolke. Men som nævnt er det heller ikke nødvendigt for at lave gode anbefalinger. En større udfordring ved neurale netværk er, at de kræver store mængder data. Det vil sige, at brugeren er nødt til at rate mange film, for at de kan benyttes. Du kan læse meget mere i vores forskellige [noter om neurale netværk<a href="../../materialer/neurale_net.html"></a>.</p>
<p>Endelig er der problemet med valg af features. Der er i princippet mange forskellige features, der kunne have betydning for brugernes ratings. Hvordan vælger man, hvilke der er mest relevante? Man kan selvfølgelig prøve sig frem, men så ryger man hurtigt ud i problemer med <em>overfitting</em>. Det kan du læse mere om i noten om <a href="../../materialer/krydsvalidering/krydsvalidering.html">Overfitting, modeludvælgelse og krydsvalidering</a>. I næste afsnit skal vi se et eksempel på, hvordan man kan lade algoritmen vælge features selv.</p>
</section>
</section>
<section id="samarbejdsbaserede-modeller-for-ratings" class="level1 page-columns page-full">
<h1>Samarbejdsbaserede modeller for ratings</h1>
<p>Da vi lavede den multiple lineære regressionsmodel, kiggede vi udelukkende på data for en enkelt bruger. Det viser sig dog, at man kan få meget mere information ud af også at lære af, hvordan andre brugere har ratet filmene. Derfor tager vi nu en samarbejdsbaseret tilgang, hvor vi tager udgangspunkt i et datasæt over alle brugeres ratings. Det kunne se ud som vist i <a href="#tbl-rates" class="quarto-xref">tabel&nbsp;4</a>. NA står for “not available” og betyder, at brugeren ikke har set filmen.</p>
<div id="tbl-rates" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-tbl figure page-columns page-full">
<div aria-describedby="tbl-rates-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Film 1</th>
<th style="text-align: center;">Film 2</th>
<th style="text-align: center;">Film 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Bruger 1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">Bruger 2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Bruger 3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">Bruger 4</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-tbl margin-caption" id="tbl-rates-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabel&nbsp;4: Eksempel på datasæt over brugeres ratings på en skala fra 1 til 5. NA angiver, at brugeren ikke har set filmen.
</figcaption>
</figure>
</div>
<section id="matrixfaktorisering" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="matrixfaktorisering">Matrixfaktorisering</h2>
<p>Den algoritme, vi vil se på, kaldes <em>matrixfaktorisering</em><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. Algoritmen blev forslået i 2006 i forbindelse med konkurrencen “The Netflix Prize”, hvor Netflix udlovede en præmie til den, der kunne forbedre firmaets egen algoritme til prædiktion af ratings med 10%. Matrixfaktorisering blev hurtigt et populært værktøj i konkurrencen og er stadig et vigtigt element i mange anbefalingssystemer.</p>
<div class="no-row-height column-margin column-container"><div id="fn8"><p><sup>8</sup>&nbsp;Hvorfor den hedder det, bliver forklaret i en boks længere nede på siden, men det er ikke nødvendigt at kende til matricer, for at forstå hvordan algoritmen virker.</p></div></div><p>I den multiple lineære regressionsmodel valgte vi selv nogle features ved filmene. Det er dog ikke oplagt, hvilke features der er mest relevante. Man kan selvfølgelig prøve sig frem, men der kan hurtigt blive mange muligheder. Det kan også være svært at definere relevante features manuelt. Hvordan måler man for eksempel hvor sjov/alvorlig en film er? Det vi vil gøre her, er, at lade algoritmen selv vælge de <span class="math inline">\(M\)</span> features. Vi betragter altså <span class="math inline">\(x_1,\ldots,x_M\)</span> som ukendte underliggende variable, også kaldet <em>latente variable</em>, som har indflydelse på, hvordan man vurderer filmen. Man kune forestille sig, at de måler diffust definerede egenskaber ved filmen, så som “hvor sjov filmen er” eller “hvor gode skuespillerne er”. Men vi det ikke, og vi behøver heller ikke at vide det, bare der kommer gode anbefalinger ud af det!</p>
<p>Vi kalder <span class="math inline">\(i\)</span>te brugers rating af <span class="math inline">\(j\)</span>te film for <span class="math inline">\(r_{ij}\)</span>. Vi vil nu gerne lave en algoritme, der kan prædiktere <span class="math inline">\(i\)</span>te brugers rating af <span class="math inline">\(j\)</span>te film. Det er altså den værdi, der står i <span class="math inline">\(i\)</span>te række og <span class="math inline">\(j\)</span>te søjle i <a href="#tbl-rates" class="quarto-xref">tabel&nbsp;4</a>. Hver film har sine egne værdier af de <span class="math inline">\(M\)</span> features. For <span class="math inline">\(j\)</span>te film betegner vi dem <span class="math inline">\(x_{1j},\ldots,x_{Mj}\)</span>. Disse værdier kalder vi <em>featurevægtene</em>. Den <span class="math inline">\(i\)</span>te brugers præferencer for de <span class="math inline">\(M\)</span> features beskrives ved <em>præferencevægtene</em> <span class="math inline">\(p_{i1},\ldots,p_{iM}\)</span>. Vi modellerer så <span class="math inline">\(i\)</span>te brugers rating af <span class="math inline">\(j\)</span>te film ved <span id="eq-modelij"><span class="math display">\[\hat{r}_{ij} = p_{i1}x_{1j} + p_{i2}x_{2j} + \dotsm + p_{iM}x_{Mj} \tag{8}\]</span></span> Det minder om den multiple lineære regressionsmodel (<a href="#eq-multipel" class="quarto-xref">5</a>). Forskellen er, at featurevægtene ikke er givet på forhånd, men er nogle, vi skal estimere ud fra data. Hvis datasættet indeholder <span class="math inline">\(p\)</span> film, og hver af dem har <span class="math inline">\(M\)</span> featurevægte, så vil der være <span class="math inline">\(M\cdot p\)</span> featurevægte i alt. Hvis der er <span class="math inline">\(n\)</span> brugere, og hver af dem har <span class="math inline">\(M\)</span> præferencevægte, vil der samlet være <span class="math inline">\(n\cdot M\)</span> præferencevægte. Det giver i alt <span class="math inline">\(M\cdot p + n\cdot M\)</span> vægte, som skal bestemmes. I et typisk datasæt vil både <span class="math inline">\(n\)</span> og <span class="math inline">\(p\)</span> være store, så der vil være et stort samlet antal vægte. Hvis <span class="math inline">\(M\)</span> vælges relativt lille, vil det samlede antal vægte dog være lille i forhold til det samlede antal kombinationer af film og bruger, som vil være <span class="math inline">\(n\cdot p\)</span>. I stedet for at skulle estimere samtlige værdier <span class="math inline">\(n\cdot p\)</span> af <span class="math inline">\(r_{ij}\)</span>, skal vi kun estimere <span class="math inline">\(M\cdot p + n\cdot M\)</span> vægte.</p>
<div class="callout callout-style-simple callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Matrixfaktorisering
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Algoritmen hedder matrixfaktorisering, fordi modellen (<a href="#eq-modelij" class="quarto-xref">8</a>) kan beskrives ved hjælp af matrixprodukter. Herunder forklarer vi, hvad det betyder. Det er ikke nødvendigt at forstå matricer og matrixprodukter for at forstå denne note, men mange algoritmer inden for kunstig intelligens kan beskrives nemmere ved hjælp af matricer.</p>
<p>Hvis der er <span class="math inline">\(n\)</span> brugere og <span class="math inline">\(p\)</span> film, kan man sætte vores datasæt fra <a href="#tbl-rates" class="quarto-xref">tabel&nbsp;4</a> op i en <span class="math inline">\((n\times p)\)</span>-matrix, som egentlig bare er et skema med <span class="math inline">\(n\)</span> rækker og <span class="math inline">\(p\)</span> søjler af tal. Kalder vi denne matrix for <span class="math inline">\(R\)</span>, skriver vi <span class="math display">\[R=\begin{bmatrix} r_{11} &amp; r_{12} &amp; \cdots &amp; r_{1p}\\
r_{21} &amp; r_{22} &amp; \cdots &amp; r_{2p}\\
  \vdots &amp; \vdots &amp;  &amp; \vdots\\
   r_{n1} &amp; r_{n2} &amp; \cdots &amp; r_{np}\\
\end{bmatrix}\]</span> Hver række i matricen svarer til en bruger, og hver søjle svarer til en film.</p>
<p>Tilsvarende kan præferencevægtene sættes op i en <span class="math inline">\((n\times M)\)</span>-matrix, hvor hver række svarer til en bruger, og hver søjle svarer til en feature.<br>
<span class="math display">\[P=\begin{bmatrix} p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1M}\\
p_{21} &amp; p_{22} &amp; \cdots &amp; p_{2M}\\
  \vdots &amp; \vdots &amp;  &amp; \vdots\\
   p_{n1} &amp; p_{n2} &amp; \cdots &amp; p_{nM}\\
\end{bmatrix}\]</span></p>
<p>Featurevægtene <span class="math inline">\(x_{j1},\ldots, x_{jp}\)</span> kan stilles op i en <span class="math inline">\((M\times p)\)</span>-matrix <span class="math display">\[X=\begin{bmatrix} x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p}\\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p}\\
  \vdots &amp; \vdots &amp;  &amp; \vdots\\
   x_{M1} &amp; x_{M2} &amp; \cdots &amp; x_{Mp}\\
\end{bmatrix}\]</span> Hver række svarer til en feature, og hver søjle svarer til en film.</p>
<p>To matricer kan ganges sammen, hvis den første har lige så mange søjler, som den anden har rækker. For eksempel er der <span class="math inline">\(M\)</span> søjler i <span class="math inline">\(P\)</span> og <span class="math inline">\(M\)</span> rækker i <span class="math inline">\(X\)</span> (begge dele svarende til de <span class="math inline">\(M\)</span> features). De kan altså ganges sammen til <em>matrixproduktet</em> <span class="math inline">\(P\cdot X\)</span>. Resultatet bliver en ny <span class="math inline">\((n\times p)\)</span>-matrix, som vi vil kalde <span class="math inline">\(\hat{R}\)</span>. Det tal, der skal stå i <span class="math inline">\(i\)</span>te række og <span class="math inline">\(j\)</span>te søjle af <span class="math inline">\(\hat{R}\)</span>, kalder vi <span class="math inline">\(\hat{r}_{ij}\)</span>. For at udregne <span class="math inline">\(\hat{r}_{ij}\)</span> skal vi bruge værdierne i <span class="math inline">\(i\)</span>te række af <span class="math inline">\(P\)</span> og <span class="math inline">\(j\)</span>te søjle af <span class="math inline">\(Q\)</span>. Vi udregner så <span class="math display">\[\hat{r}_{ij} =  p_{i1}x_{1j} +p_{i2}x_{2j} + \dotsm + p_{iM}x_{Mj} \]</span> Dette stemmer netop overens med modellen (<a href="#eq-model" class="quarto-xref">6</a>). Vi kan derfor skrive vores model kort som <span class="math display">\[\hat{R} = P\cdot X\]</span> Det vil sige, at vores rating-matrix <span class="math inline">\(\hat{R}\)</span> er faktoriseret som et produkt af to matricer. Deraf navnet matrixfaktorisering.</p>
</div>
</div>
</div>
<section id="korrektion-af-modellen" class="level3">
<h3 class="anchored" data-anchor-id="korrektion-af-modellen">Korrektion af modellen</h3>
<p>Da vi lavede multipel lineær regression, var der også en skæring i modellen, som svarede til ratingen, når alle features var nul. Tilsvarende er det oplagt at tilføje en skæring i<br>
(<a href="#eq-model" class="quarto-xref">6</a>). Det gøres ofte med modellen <span class="math display">\[\hat{r}_{ij} =  b + c_i + d_j+ p_{i1}x_{1j} +p_{i2}x_{2j} + \dotsm + p_{iM}x_{Mj} \]</span> Her angiver <span class="math inline">\(b\)</span> den gennemsnitlige rating for alle film, når alle featurevægte er nul. Hver bruger har desuden et personligt led <span class="math inline">\(c_i\)</span>, der tager højde for, at nogle brugere er mere tilbøjelige til at give høje ratings end andre. Hvis <span class="math inline">\(c_i\)</span> er positiv, giver brugeren højere ratings end gennemsnittet, mens hvis <span class="math inline">\(c_i\)</span> er negativ, giver brugeren lavere ratings end gennemsnittet. På samme måde har hver film har et led <span class="math inline">\(d_j\)</span>, der korrigerer for, at nogle film generelt får højere ratings end andre. Hvis <span class="math inline">\(d_j\)</span> er positiv, får filmen højere ratings end gennemsnittet, mens hvis <span class="math inline">\(d_j\)</span> er negativ, får filmen dårligere ratings end gennemsnittet. For nemheds skyld arbejder vi videre med modellen (<a href="#eq-matrixfak" class="quarto-xref">9</a>) i det følgende.</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opgave 6: Antal vægte som skal estimeres
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Antag, at en streamingtjeneste har <span class="math inline">\(n=1.000.000\)</span> brugere og et katalog på <span class="math inline">\(10.000\)</span> film.</p>
<ul>
<li><p>Hvis vi skulle estimere alle ratings <span class="math inline">\(r_{ij}\)</span> for alle kombinationer af film og bruger, hvor mange ratings skulle vi så estimere i alt?</p></li>
<li><p>Hvis vi bruger modellen (<a href="#eq-matrixfak" class="quarto-xref">9</a>) med <span class="math inline">\(M=5\)</span>, hvor mange vægte skal vi så estimere i alt?</p></li>
<li><p>Hvis vi skulle lave en multipel regressionsmodel for hver eneste bruger med <span class="math inline">\(M=5\)</span> features, hvor mange vægte skulle vi så bruge i alt?</p></li>
</ul>
</div>
</div>
</div>
</section>
</section>
<section id="estimation-af-vægte-1" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="estimation-af-vægte-1">Estimation af vægte</h2>
<p>For at kunne bruge modellen i (<a href="#eq-matrixfak" class="quarto-xref">9</a>) skal vi have estimeret alle featurevægtene <span class="math inline">\(x_{1j},x_{2j},\ldots,x_{Mj}\)</span> og alle præferencevægtene <span class="math inline">\(p_{i1},p_{i2},\ldots, p_{iM}\)</span>. Til det formål tager vi udgangspunkt i et datasæt på formen i <a href="#tbl-rates" class="quarto-xref">tabel&nbsp;4</a>, som streamingtjenesten har indsamlet.</p>
<p>Vi ønsker at prædiktere <span class="math inline">\(i\)</span>te brugers rating af <span class="math inline">\(j\)</span>te film ved <span id="eq-matrixfak"><span class="math display">\[\hat{r}_{ij} = p_{i1}x_{1j} + p_{i2}x_{2j} + \dotsm + p_{iM}x_{Mj} \tag{9}\]</span></span> Som i den multiple lineære regressionsmodel, sammenligner vi prædiktionen <span class="math inline">\(\hat{r}_{ij}\)</span> med de faktiske ratings <span class="math inline">\(r_{ij}\)</span>. Hvis modellen er god, vil vi gerne have, at prædiktionsfejlen <span class="math inline">\(r_{ij}-\hat{r}_{ij}\)</span> er tæt på 0 svarende til, at den kvadrerede prædiktionsfejl <span class="math inline">\((r_{ij}-\hat{r}_{ij})^2\)</span> er lille. Vi definerer en tabsfunktion <span class="math display">\[E=\sum_{r_{ij} \neq NA} (r_{ij}-\hat{r}_{ij})^2 \]</span> Her betyder <span class="math inline">\(r_{ij}\neq NA\)</span> under sumtegnet, at vi kun skal tage summen af de led, hvor vi kender den faktiske rating (<span class="math inline">\(r_{ij}=NA\)</span> betød jo, at brugeren ikke havde ratet filmen, så i det tilfælde kan vi ikke udregne en prædiktionsfejl).</p>
<p>Igen ønsker vi at finde de vægte, der minimerer tabsfunktionen. I modsætning til multipel lineær regression, kan de ligninger, man får ud af at udregne de partielle afledte og sætte dem lig nul, ikke løses eksplicit. I stedet kan man finde minimum ved hjælp af en populær algoritme inden for kunstig intelligens, der hedder <a href="../../materialer/gradientnedstigning/gradientnedstigning.html">gradientnedstigning</a>. For at kunne bruge den, skal man kende de partielle afledte af <span class="math inline">\(E\)</span> med hensyn til vægtene. For at finde dem, kan vi først bemærke, at <span class="math inline">\(E\)</span> er en sum, og en sum differentieres som bekendt ledvist. I en opgave nedenfor viser I, at de patielt afledte af et enkelt led i <span class="math inline">\(E\)</span> er givet ved <span id="eq-partiel1"><span class="math display">\[
\begin{aligned}
\frac{\partial }{\partial p_{im}} (r_{ij}-\hat{r}_{ij})^2 = -2 (r_{ij}-\hat{r}_{ij})x_{mj}\\
\frac{\partial }{\partial x_{mj}} (r_{ij}-\hat{r}_{ij})^2 = -2 (r_{ij}-\hat{r}_{ij})p_{im}
\end{aligned}
\tag{10}\]</span></span> Desuden gælder der for <span class="math inline">\(l\neq i\)</span>, at <span id="eq-partiel2"><span class="math display">\[
\frac{\partial }{\partial p_{lm}} (r_{ij}-\hat{r}_{ij})^2 = 0
\tag{11}\]</span></span> og for <span class="math inline">\(k \neq j\)</span> <span id="eq-partiel3"><span class="math display">\[
\frac{\partial }{\partial x_{mk}} (r_{ij}-\hat{r}_{ij})^2 = 0
\tag{12}\]</span></span> Disse formler gør, at en computer nemt kan lave gradientnedstigning.</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opgave 7: Ratings
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<ol type="1">
<li>Tre brugere har ratet tre film som følger:</li>
</ol>
<div id="tbl-rij" class="bordered quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure" aria-labelledby="tbl-rij-caption">
<div aria-describedby="tbl-rij-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-bordered table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">"Titanic"</th>
<th style="text-align: center;">"Ringenes Herre"</th>
<th style="text-align: center;">"Jurassic park"</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Bruger 1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">Bruger 2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Bruger 3</td>
<td style="text-align: center;">NA</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
</div>

</figure>
</div>
<p>Vi betragter en model på formen (<a href="#eq-matrixfak" class="quarto-xref">9</a>) med <span class="math inline">\(M=2\)</span> features. De tre film har featurevægtene:</p>
<div id="tbl-features" class="bordered quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure" aria-labelledby="tbl-features-caption">
<div aria-describedby="tbl-features-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-bordered table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">"Titanic"</th>
<th style="text-align: center;">"Ringenes Herre"</th>
<th style="text-align: center;">"Jurassic park"</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x_1\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(x_2\)</span></td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
</div>

</figure>
</div>
<p>De tre brugere har præferencevægtene:</p>
<div id="tbl-preferences" class="bordered quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure" aria-labelledby="tbl-preferences-caption">
<div aria-describedby="tbl-preferences-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-bordered table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(p_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(p_2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Bruger 1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">Bruger 2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Bruger 3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
</div>

</figure>
</div>
<ul>
<li>Lav en tabel over alle de prædikterede ratings <span class="math inline">\(\hat{r}_{ij}\)</span>.</li>
<li>Beregn prædiktionsfejlen <span class="math inline">\(r_{ij}-\hat{r}_{ij}\)</span> for alle de film, der faktisk er blevet ratet af brugerne (det vil sige, hvor <span class="math inline">\(r_{ij}\neq NA\)</span> i <a href="#tbl-rij" class="quarto-xref">tabel&nbsp;5</a>).</li>
<li>Beregn tabsfunktionen <span class="math inline">\(E\)</span>.</li>
</ul>
</div>
</div>
</div>
<div id="tbl-rij-caption" class="margin-figure-caption column-margin callout-9-contents callout-collapse collapse show callout-margin-content callout-margin-content-simple">
Tabel&nbsp;5: Tabel over ratings.
</div><div id="tbl-features-caption" class="margin-figure-caption column-margin callout-9-contents callout-collapse collapse show callout-margin-content callout-margin-content-simple">
Tabel&nbsp;6: Tabel over featurevægte.
</div><div id="tbl-preferences-caption" class="margin-figure-caption column-margin callout-9-contents callout-collapse collapse show callout-margin-content callout-margin-content-simple">
Tabel&nbsp;7: Tabel over præferencevægte.
</div><div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Opgave 8: Partielle afledede
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Vis, at de partielle afledte af <span class="math inline">\((r_{ij}-\hat{r}_{ij})^2\)</span> med hensyn til vægtene er givet ved formlerne (<a href="#eq-partiel1" class="quarto-xref">10</a>), (<a href="#eq-partiel2" class="quarto-xref">11</a>) og (<a href="#eq-partiel3" class="quarto-xref">12</a>).</p>
</div>
</div>
</div>
</section>
</section>
<section id="moderne-anbefalingssystemer" class="level1">
<h1>Moderne anbefalingssystemer</h1>
<p>Vi har skelnet mellem indholdsbaserede og samarbejdsbaserede anbefalingssystemer. De algoritmer der bruges i praksis indeholder dog elementer fra begge dele. Du vil også se, at tjenesterne laver forskellige slags anbefalinger, for eksempel af typen "specielt til dig", "andre har også set" eller "fordi du så".</p>
<p>Nogle af de datatyper, tjenesterne indsamler, er særligt komplicerede. Det kunne for eksempel være rækkefølgen, du ser filmene i. De senest sete film er typisk mest relevante for dit næste valg. Hvis du lige har set fem kattevideoer på YouTube, er det sandsynligt, at du er i humør til endnu en kattevideo. Her benyttes faktisk nogle af de samme algoritmer, som bruges af de store sprogmodeller, der indgår i blandt andet ChatGPT og Google Translate (du kan læse mere i vores <a href="../../materialer/sprogmodeller.html">noter om sprogmodeller</a>). Ligesom filmenes rækkefølge er vigtig, er det nemlig også vigtigt for sprogmodellerne at kunne tage højde for ordenes rækkefølge i en tekst. Modellerne har derfor meget tilfælles.</p>
<p>Som nævnt er det afgørende i konkurrencen mellem streamingtjenester, at de er i stand til at levere gode anbefalinger til brugerne. Derfor arbejdes der også til stadighed på at gøre algoritmerne bedre.</p>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/aimat\.dk");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>